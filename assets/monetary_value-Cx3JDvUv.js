var x=Object.defineProperty;var b=(r,e,n)=>e in r?x(r,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[e]=n;var o=(r,e,n)=>b(r,typeof e!="symbol"?e+"":e,n);import{r as P,T as w,B as S,a as M,b as $,s as T,d as m,g as y,A as O,h as X,j as V}from"./string-CeEx6zFN.js";const f="InvalidInputError";class l extends S{constructor(e="invalid input"){super(e),Object.freeze(this)}get code(){return f}}class A{convert(e){return M(e,"code","message"),$(e,f),new l(T.decode(e.message))}}class J extends m{}class U extends w{constructor(){super(...arguments);o(this,"encoder",new J);o(this,"decoder",new A)}}const k=new U;P(f,k);class i{constructor(e,n,t){o(this,"significantDigitsMultiplier");this.alpha3Code=e,this.code=n,this.significantDigits=t,this.alpha3Code=e,this.code=n,this.significantDigits=t,this.significantDigitsMultiplier=BigInt(10)**BigInt(this.significantDigits)}toJSON(){return g.encode(this)}}const I=new i("JPY",392,0),N=new i("GBP",826,2),D=new i("USD",840,2),H=new i("EUR",978,2),R=new i("XXX",999,2),E=new i("ETH",1001,18),h=new i("XBT",1002,8),v=new i("ESP",10001,18),Y=[I,N,D,H,R,E,h,v],j=new Map(Y.map(r=>[r.alpha3Code,r]));class G{convert(e){if(typeof e!="string")throw new l("CurrencyCodeDecoder: expected string");if(e==="BTC")return h;const n=j.get(e);if(n===void 0)throw new l(`CurrencyCodeDecoder: unknown currency: "${e}"`);return n}}class z{convert(e){return y(e,i),e.alpha3Code}}class K extends w{constructor(){super(...arguments);o(this,"decoder",new G);o(this,"encoder",new z)}}const g=new K;class c{constructor(e,n){this.currency=e,this.value=n,this.currency=e,this.value=n}static USD(e){return new c(D,BigInt(e))}static ETH(e){return new c(E,BigInt(e))}static ESP(e){return new c(v,BigInt(e))}static JPY(e){return new c(I,BigInt(e))}static BTC(e){return new c(h,BigInt(e))}toString(){return u.encode(this)}toJSON(){return u.encode(this)}}function W(r){return r==="."||r===","||r===" "}function q(r,e){let n=-1;const t=r.length;for(let s=0;s<t;s++)e(r[s])&&(n=s);return n}class F{parseCurrencyCode(e){return g.decode(e)}parseValue(e,n){let t=1n;n[0]==="-"&&(t=-1n,n=n.substring(1));const s=q(n,W);if(s===-1){const B=BigInt(n.replace(/\D/g,""))*e.significantDigitsMultiplier;return t*B}const a=n.substring(0,s).replace(/\D/g,""),d=n.substring(s+1).replace(/\D/g,""),C=BigInt(a)*e.significantDigitsMultiplier,p=BigInt(d)*10n**BigInt(e.significantDigits-d.length);return t*(C+p)}convert(e){if(typeof e!="string")throw new l("MonetaryValueDecoder: expected string");const n=e.indexOf(" ");if(n<=-1)throw new l("MonetaryValueDecoder: missing non-breaking space");const t=e.substring(0,n),s=e.substring(n+1);if(/^-?[\d .,]+$/.test(t)){const d=this.parseCurrencyCode(s);return new c(d,this.parseValue(d,t))}const a=this.parseCurrencyCode(t);return new c(a,this.parseValue(a,s))}}class L{convert(e){y(e,c);const n=e.value<0n?"-":"",t=e.value<0n?-e.value:e.value,s=t%e.currency.significantDigitsMultiplier,a=t/e.currency.significantDigitsMultiplier,d=String(a),C=String(s);return/^0+$/.test(C)?`${g.encode(e.currency)} ${n}${d}`:`${g.encode(e.currency)} ${n}${a}.${String(s).padStart(e.currency.significantDigits,"0")}`}}class Q extends w{constructor(){super(...arguments);o(this,"decoder",new F);o(this,"encoder",new L)}}const u=new Q,ee=new O(new X(u),new V(u));export{l as I,c as M,g as c,ee as m};
