class d extends Error{key;haveType;constructor(e,o,t=`expected object with key: "${o}", instead found ${e}`){super(t),this.haveType=e,this.key=o,Object.freeze(this)}toJSON(){return{code:d.name,message:this.message,have:this.haveType,key:this.key}}}class a{encode(e){return this.encoder.convert(e)}decode(e){return this.decoder.convert(e)}}class s extends a{}function Y(r){return typeof r=="boolean"}function Z(r){return typeof r=="number"}function i(r){return typeof r=="string"}function _(r){return typeof r=="bigint"}function E(r){return typeof r=="object"&&r!==null}function p(r){return r!==void 0}function b(r,e){return Array.isArray(r)&&r.every(e)}function x(r){return e=>b(e,r)}function ee(r,e,o){return E(r)&&e in r&&o(r[e])}function re(r,...e){return E(r)&&e.every(o=>o in r)}function g(r,...e){if(typeof r!="object")throw new Error("expected object");if(r===null)throw new Error("received null");for(const o of e)if(!(o in r))throw new d("object",o)}function $(r,e){if(!i(r.code))throw new Error("code must be a string");if(r.code!==e)throw new Error(`expected code to be ${e}, got ${r.code}`)}function oe(r,e){if(!i(r.type))throw new Error("type must be a string");if(r.type!==e)throw new Error(`expected type to be ${e}, got ${r.type}`)}class k{assert(){}}function N(){return new k}const j=N();function u(r,e){j.assert(r,e)}function A(r,e){u(typeof r===e,`type assertion failed: expected "${e}", received "${typeof r}"`)}function T(r){u(r!==null,"expected a non-null value, received null")}function l(r,e){u(r instanceof e,`given value is not an instance of "${e.name}", specific type is "${typeof r=="object"&&r!==null?r.constructor.name:typeof r}"`)}class m extends Error{constructor(e){super(e)}get code(){return this.constructor.name}toJSON(){return v.convert(this)}}class O{convert(e){return l(e,m),{code:e.code,message:e.message}}}const v=new O,S="NoCodecFoundError";class c extends Error{codec;constructor(e,o=`no codec found for: "${e}"`){super(o),this.codec=e,Object.freeze(this);debugger}toJSON(){return{code:n.encode(c.name),message:n.encode(this.message),codec:n.encode(this.codec)}}get code(){return S}}const f=new Map;class I{convert(e){g(e,"code");const o=n.decode(e.code),t=f.get(o);if(!t)throw new c(o);return t.decode(e)}}class D{convert(e){const o=f.get(e.code);if(!o)throw new c(e.code);return o.encode(e)}}class B extends a{encoder=new D;decoder=new I}const ne=new B;function R(r,e){f.set(r,e)}const w="InvalidTypeError";class h extends m{have;want;constructor(e,o,t=`invalid type: have "${e}", want "${o}"`){super(t),this.have=e,this.want=o,Object.freeze(this)}toJSON(){return C.encode(this)}get code(){return w}}class z{convert(e){return g(e,"code","have","want","message"),$(e,w),new h(n.decode(e.have),n.decode(e.want),n.decode(e.message))}}class J{convert(e){return l(e,h),{...v.convert(e),have:n.encode(e.have),want:n.encode(e.want)}}}class U extends s{encoder=new J;decoder=new z}const C=new U;R(w,C);const F=x(p);class K{convert(e){return e}}const y=new K;class M extends a{encoder=y;decoder=y}const te=new M;class W{itemCodec;constructor(e){this.itemCodec=e}convert(e){if(!F(e)){const o=typeof e=="object"&&e!==null?e.constructor.name:typeof e,t="array";throw new Error(`invalid array value: have "${o}", want "${t}"`)}return e.map(o=>this.itemCodec.decode(o))}}class q{itemCodec;constructor(e){this.itemCodec=e}convert(e){return l(e,Array),e.map(o=>this.itemCodec.encode(o))}}class G extends s{encoder;decoder;constructor(e,o){super(),this.encoder=o,this.decoder=e}}class H{itemCodec;constructor(e){this.itemCodec=e}convert(e){return e===null?null:this.itemCodec.decode(e)}}class L{itemCodec;constructor(e){this.itemCodec=e}convert(e){return e===null?null:(T(e),this.itemCodec.encode(e))}}class P extends s{encoder;decoder;constructor(e,o){super(),this.encoder=o,this.decoder=e}}class Q{convert(e){if(!i(e))throw new h(typeof e,"string");return e}}class V{convert(e){return A(e,"string"),e}}class X extends s{encoder=new V;decoder=new Q}const n=new X;new G(new W(n),new q(n));const se=new P(new H(n),new L(n));function ce(r){return!r||!r.trim()?null:r}export{G as A,m as B,a as C,ce as D,re as E,h as I,P as N,s as T,O as a,g as b,$ as c,v as d,l as e,H as f,L as g,A as h,_ as i,Z as j,i as k,W as l,q as m,oe as n,T as o,c as p,Y as q,R as r,n as s,u as t,te as u,F as v,ee as w,p as x,ne as y,se as z};
