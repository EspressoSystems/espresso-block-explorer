var J=Object.defineProperty;var K=(e,r,s)=>r in e?J(e,r,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[r]=s;var l=(e,r,s)=>K(e,typeof r!="symbol"?r+"":r,s);import{j as t}from"./jsx-runtime-BlAj40OV.js";import{T as a}from"./Text-BU7JBOLk.js";import{r as O,B as $,T as G,a as Q,b as X,s as Y,d as Z}from"./string-Cg6lWpsr.js";import{F as ee}from"./FetchError-BbxpOD7A.js";import{E as c,U as d,u as m,c as p,d as h}from"./LoadingProvider-Cu0dkHek.js";import{W as te}from"./CircularBuffer-DsMFogiw.js";import{R as o}from"./index-Cs7sjTYM.js";import{a as U,b as q}from"./higher_order-DnPEgWEz.js";import"./DateTimeFormattersProvider-D6Gp1Kbv.js";import"./LocaleProvider-B0_30C1H.js";import"./NavDrawerStateProvider-HpepdHmi.js";import"./NowProvider-D4xjbY-7.js";import"./NumberFormattersProvider-DANbX_lC.js";import"./PathResolverProvider-Xv58eOQd.js";import{A as u}from"./AsyncIterableResolver-jWGEzNjz.js";import{P as y}from"./PromiseResolver-ZbtEiQb_.js";import{C as re}from"./CopyButton-D1h3IHuG.js";/* empty css               */import{c as oe}from"./typography-51eEIY7Y.js";const T="WebSocketError";class M extends ${constructor(s,g=`websocket error: ${String(s)}`){super(g);l(this,"cause");this.cause=s,Object.freeze(this)}get code(){return T}}class se{convert(r){return Q(r,"code","message"),X(r,T),new M({},Y.decode(r.message))}}class ae extends Z{}class ne extends G{constructor(){super(...arguments);l(this,"encoder",new ae);l(this,"decoder",new se)}}const ie=new ne;O(T,ie);const n=e=>t.jsx("p",{className:"error-display--description",children:e.children});try{n.displayName="ErrorDescription",n.__docgenInfo={description:`ErrorDescription represents the string contents of an Error Display.  More
specifically, how the message of the error is conveyed to the end-user.`,displayName:"ErrorDescription",props:{}}}catch{}const i=e=>t.jsx("strong",{className:"error-display--title",children:e.children});try{i.displayName="ErrorTitle",i.__docgenInfo={description:`ErrorTitle represents the title element of an error. This is provided in
order to have a consistent look and feel for error messages.`,displayName:"ErrorTitle",props:{}}}catch{}const N=e=>o.useContext(c)?t.jsx(ce,{...e,children:t.jsx(V,{})}):t.jsx(t.Fragment,{}),ce=({className:e,children:r,...s})=>t.jsx("div",{className:U(e,"error-display-wrapper"),...s,children:r}),V=()=>{const e=o.useContext(c);if(e instanceof te){const r=e.error;return t.jsx(c.Provider,{value:r,children:t.jsx(V,{})})}return e instanceof $?t.jsx(de,{}):t.jsx(he,{})},de=()=>{const e=o.useContext(c);return e instanceof ee?t.jsx(le,{}):e instanceof M?t.jsx(me,{}):e instanceof d?t.jsx(pe,{}):t.jsx(ue,{})},le=()=>t.jsxs(t.Fragment,{children:[t.jsx(i,{children:t.jsx(a,{text:"Fetch Error"})}),t.jsx(n,{children:t.jsx(a,{text:"This is a class of error that indicates that the attempt to communicate with the remote server has failed.  More specifically, something is preventing us from reaching the server.  This may be due a faulty inconsistent connection, bad or outdated DNS results, a bad URL, or even the addressed server not being reachable."})})]}),me=()=>t.jsxs(t.Fragment,{children:[t.jsx(i,{children:t.jsx(a,{text:"WebSocket Error"})}),t.jsx(n,{children:t.jsx(a,{text:"This is a class of error that indicates that the attempt to communicate with the remote server with the intent to setup a WebSocket has failed.  More specifically, something is preventing us from reaching the server.  This may be due a faulty inconsistent connection, bad or outdated DNS results, a bad URL, or even the addressed server not being reachable."})})]}),pe=()=>t.jsxs(t.Fragment,{children:[t.jsx(i,{children:t.jsx(a,{text:"Unimplemented Error"})}),t.jsx(n,{children:t.jsx(a,{text:"This error indicates that there is a case in the logic that we didn't handle, or have intentionally ignored.  In either case, this should not make it to the end user, and as such should be reported"})})]}),he=()=>{const e=o.useContext(c);return o.useEffect(()=>(console.error("encountered an unhandled native error in ErrorDisplay:",e),()=>{})),t.jsxs(t.Fragment,{children:[t.jsx(i,{children:t.jsx(a,{text:"Native JavaScript Error"})}),t.jsx(n,{children:t.jsx(a,{text:"This error should only be displayed if we haven't caught an error.  This also indicates that this is going to be an unhandled error on the Developer's side"})})]})},ue=()=>{const e=o.useContext(c);return o.useEffect(()=>(console.error("encountered unhandled error in component ErrorDisplay:",e),()=>{})),t.jsxs(t.Fragment,{children:[t.jsx(i,{children:t.jsx(a,{text:"Unhandled Error"})}),t.jsx(n,{children:t.jsx(a,{text:"An unhandled error has been thrown that prevents progress.  There is no dedicated error message for this error, so please check the developer console for the specific details."})})]})};try{N.displayName="ErrorDisplay",N.__docgenInfo={description:`ErrorDisplay is a component that attempts to display an error message to the
end-user. This components is meant for flexibility in that it handles the
specific error via some sub-component.  This component also guards against
non-existing errors retrieved from the ErrorContext.`,displayName:"ErrorDisplay",props:{className:{defaultValue:null,description:"",name:"className",required:!1,type:{name:"string"}}}}}catch{}const j=e=>t.jsx("div",{className:"skeleton-content",...e});try{j.displayName="SkeletonContent",j.__docgenInfo={description:"",displayName:"SkeletonContent",props:{}}}catch{}function ye(e){return q(e,"edge-margin")}function H(e){return q(e,"loading-shimmer")}try{H.displayName="WithLoadingShimmer",H.__docgenInfo={description:`WithLoadingShimmer is a higher order component that adds the loading-shimmer
class to the given component.`,displayName:"WithLoadingShimmer",props:{}}}catch{}const _=oe("p");try{_.displayName="ParagraphTextSmall",_.__docgenInfo={description:`ParagraphTextSmall represents the standard Paragraph element to be utilized
within the Block Explorer.`,displayName:"ParagraphTextSmall",props:{className:{defaultValue:null,description:"",name:"className",required:!1,type:{name:"string"}}}}}catch{}const x=o.createContext({async retrieve(){throw new d}}),E=({...e})=>{const r=o.useContext(x);return t.jsx(y,{promise:r.retrieve(),children:t.jsx(t.Fragment,{children:e.children})})},f=o.createContext(m()),R=e=>{const r=o.useContext(f);return t.jsx(p,{children:t.jsx(u,{asyncIterable:r,children:t.jsx(h,{children:e.children})})})};try{x.displayName="BlockSizeHistogramAsyncRetrieverContext",x.__docgenInfo={description:`The BlockSizeHistogramAsyncRetrieverContext is a React context that is
used to store the BlockSizeHistogramAsyncRetriever.  This retriever can
be used to retrieve the size histogram data.`,displayName:"BlockSizeHistogramAsyncRetrieverContext",props:{}}}catch{}try{E.displayName="BlockSizeHistogramLoader",E.__docgenInfo={description:"BlockSizeHistogramLoader is a component that is used to consume any\ndata the can be retrieved from the AsyncRetriever defined by the current\nBlockSizeHistogramAsyncRetrieverContext.  It does this via a\n`PromiseResolver`. Any children passed into this component will be passed\nthe resolved contexts of the `PromiseResolver`.",displayName:"BlockSizeHistogramLoader",props:{}}}catch{}try{f.displayName="BlockSizeHistogramStreamContext",f.__docgenInfo={description:`BlockSizeHistogramStreamContext is a React context that is used to store the
BlockSizeHistogramData.  This data can be used to stream the size histogram
data.`,displayName:"BlockSizeHistogramStreamContext",props:{}}}catch{}try{R.displayName="BlockSizeHistogramStreamConsumer",R.__docgenInfo={description:`BlockSizeHistogramStreamConsumer is a component that is used to consume the
data that is stored in the BlockSizeHistogramStreamContext.  This data is
expected to be streamed to the children of this component.`,displayName:"BlockSizeHistogramStreamConsumer",props:{}}}catch{}const k=o.createContext({async retrieve(){throw new d}}),I=({...e})=>{const r=o.useContext(k);return t.jsx(y,{promise:r.retrieve(),children:t.jsx(t.Fragment,{children:e.children})})},v=o.createContext(m()),L=e=>{const r=o.useContext(v);return t.jsx(p,{children:t.jsx(u,{asyncIterable:r,children:t.jsx(h,{children:e.children})})})};try{k.displayName="BlockThroughputHistogramAsyncRetrieverContext",k.__docgenInfo={description:`The BlockThroughputHistogramAsyncRetrieverContext is a React context that is
used to store the BlockThroughputHistogramAsyncRetriever.  This retriever can
be used to retrieve the throughput histogram data.`,displayName:"BlockThroughputHistogramAsyncRetrieverContext",props:{}}}catch{}try{I.displayName="BlockThroughputHistogramLoader",I.__docgenInfo={description:"BlockThroughputHistogramLoader is a component that is used to consume any\ndata the can be retrieved from the AsyncRetriever defined by the current\nBlockThroughputHistogramAsyncRetrieverContext.  It does this via a\n`PromiseResolver`.  Any children passed into this component will be passed\nthe resolved contexts of the `PromiseResolver`.",displayName:"BlockThroughputHistogramLoader",props:{}}}catch{}try{v.displayName="BlockThroughputHistogramStreamContext",v.__docgenInfo={description:"BlockThroughputHistogramStreamContext is a React context that is used to\nmake available an `AsyncIterable` stream of data that conforms to the type of\nBlockThroughputHistogramData`.  This stream is expected to be reactively\nupdated.",displayName:"BlockThroughputHistogramStreamContext",props:{}}}catch{}try{L.displayName="BlockThroughputHistogramStreamConsumer",L.__docgenInfo={description:"BlockThroughputHistogramStreamConsumer is a component that is used to consume\nthe `AsyncIterable` stream of data that is defined by the current\n`BlockThroughputHistogramStreamContext`. It consumes this `AsyncIterable`\nstream by using the `AsyncIterableResolver` component. Any children passed\ninto this component will be passed the resolved contexts of the\n`AsyncIterableResolver`.",displayName:"BlockThroughputHistogramStreamConsumer",props:{}}}catch{}const S=o.createContext({async retrieve(){throw new d}}),A=({...e})=>{const r=o.useContext(S);return t.jsx(y,{promise:r.retrieve(),children:t.jsx(t.Fragment,{children:e.children})})},C=o.createContext(m()),D=e=>{const r=o.useContext(C);return t.jsx(p,{children:t.jsx(u,{asyncIterable:r,children:t.jsx(h,{children:e.children})})})};try{S.displayName="BlockTimeHistogramAsyncRetrieverContext",S.__docgenInfo={description:`The BlockTimeHistogramAsyncRetrieverContext is a React context that is
used to store the BlockTimeHistogramAsyncRetriever.  This retriever can
be used to retrieve the time histogram data.`,displayName:"BlockTimeHistogramAsyncRetrieverContext",props:{}}}catch{}try{A.displayName="BlockTimeHistogramLoader",A.__docgenInfo={description:"BlockTimeHistogramLoader is a component that is used to consume any\ndata the can be retrieved from the AsyncRetriever defined by the current\nBlockTimeHistogramAsyncRetrieverContext.  It does this via a\n`PromiseResolver`. Any children passed into this component will be passed\nthe resolved contexts of the `PromiseResolver`.",displayName:"BlockTimeHistogramLoader",props:{}}}catch{}try{C.displayName="BlockTimeHistogramStreamContext",C.__docgenInfo={description:`The BlockTimeHistogramStreamContext is a React context that is used to store
the BlockTimeHistogramData.  This data can be used to stream the time
histogram data.`,displayName:"BlockTimeHistogramStreamContext",props:{}}}catch{}try{D.displayName="BlockTimeHistogramStreamConsumer",D.__docgenInfo={description:"BlockTimeHistogramStreamConsumer is a component that is used to consume any\ndata that can be streamed from the BlockTimeHistogramStreamContext.  It does\nthis via an `AsyncIterableResolver`.  Any children passed into this component\nwill be passed the resolved contexts of the `AsyncIterableResolver`.",displayName:"BlockTimeHistogramStreamConsumer",props:{}}}catch{}const B=o.createContext({retrieve(){throw new d}}),w=o.createContext({height:0,time:new Date,size:0,transactions:0,proposer:[]}),z=e=>{const r=o.useContext(B);return t.jsx(y,{promise:r.retrieve(),children:e.children})},b=o.createContext(m()),P=e=>{const r=o.useContext(b);return t.jsx(p,{children:t.jsx(u,{asyncIterable:r,children:t.jsx(h,{children:e.children})})})};try{B.displayName="LatestBlockSummaryLoaderContext",B.__docgenInfo={description:`The LatestBlockAsyncRetriever is an interface that is used to
retrieve the data that is expected to be displayed on the Latest Block
Summary. It is expected to be used to retrieve the data asynchronously.`,displayName:"LatestBlockSummaryLoaderContext",props:{}}}catch{}try{w.displayName="LatestBlockSummaryProvider",w.__docgenInfo={description:`The LatestBlockSummaryProvider is a React context that is used to store the
LatestBlock.  This context can be used to retrieve the latest block summary.
It is expected to be used to retrieve the data asynchronously.`,displayName:"LatestBlockSummaryProvider",props:{}}}catch{}try{z.displayName="LatestBlockSummaryDataLoader",z.__docgenInfo={description:"LatestBlockSummaryDataLoader is a component that is used to consume any\ndata the can be retrieved from the AsyncRetriever defined by the current\nLatestBlockSummaryLoaderContext.  It does this via a `PromiseResolver`.\nAny children passed into this component will be passed the resolved contexts\nof the `PromiseResolver`.",displayName:"LatestBlockSummaryDataLoader",props:{}}}catch{}try{b.displayName="LatestBlockSummaryStreamContext",b.__docgenInfo={description:`The LatestBlockSummaryStreamContext is a React context that is used to store
the LatestBlock.  This data can be used to stream the latest block summary.`,displayName:"LatestBlockSummaryStreamContext",props:{}}}catch{}try{P.displayName="LatestBlockSummaryStreamConsumer",P.__docgenInfo={description:"LatestBlockSummaryStreamConsumer is a component that is used to consume\nthe `AsyncIterable` stream of data that is defined by the current context.\nIt does this via an `AsyncIterableResolver`.  Any children passed into this\ncomponent will be passed the resolved contexts of the `AsyncIterableResolver`.",displayName:"LatestBlockSummaryStreamConsumer",props:{}}}catch{}const W=e=>t.jsxs("span",{className:"inline",children:[e.children,t.jsx(re,{content:e.value.toString()})]});try{W.displayName="CopyTaggedBase64",W.__docgenInfo={description:"CopyTaggedBase64 is a component that will display a `CopyButton` with the contents\nfor the `CopyButton` being the base64 representation of the given TaggedBase64\ngiven in the `value` prop.",displayName:"CopyTaggedBase64",props:{value:{defaultValue:null,description:"",name:"value",required:!0,type:{name:"TaggedBase64"}}}}}catch{}const ge=ye(_),F=e=>t.jsx("div",{...e,className:U(e.className,"fake-data-notice"),children:t.jsx(ge,{children:"This Demo contains fake data and navigation that is not indicative of the final product."})});try{F.displayName="FakeDataNotice",F.__docgenInfo={description:"",displayName:"FakeDataNotice",props:{className:{defaultValue:null,description:"",name:"className",required:!1,type:{name:"string"}}}}}catch{}class ze{explorer(){return"/?path=/story/pages-explorer--explorer"}blocks(r){return r!==void 0?`/?path=/story/pages-blocks--blocks&args=startAtBlock:${r}`:"/?path=/story/pages-blocks--blocks"}block(r){return`/?path=/story/pages-block--block&args=block:${r}`}transactions(r,s){return r!==void 0?`/?path=/story/pages-transactions--transactions&args=startAtBlock:${r};offset:${s??0}`:"/?path=/story/pages-transactions--transactions"}transactionsForBlock(r){return`/?path=/story/pages-transactions-for-block--transactions-for-block&args=block:${r}`}transaction(r,s){return`/?path=/story/pages-transaction--transaction&args=height:${r};offset:${s}`}rollUps(){return"/?path=/story/pages-rollups--rollups"}rollUp(r,s,g){return s!==void 0?`/?path=/story/pages-rollup--rollup&args=namespace:${r};startAtBlock:${s};offset:${g??0}`:`/?path=/story/pages-rollup--rollup&args=namespace:${r}`}nodes(){return"/?path=/story/pages-nodes--nodes"}}export{A as B,W as C,N as E,F,z as L,ze as S,ye as W,H as a,E as b,I as c,j as d,w as e,B as f,S as g,x as h,k as i,b as j,C as k,f as l,v as m,P as n,D as o,R as p,L as q};
