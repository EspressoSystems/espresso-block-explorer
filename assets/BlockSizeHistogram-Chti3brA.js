var ve=Object.defineProperty;var Te=(e,s,n)=>s in e?ve(e,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[s]=n;var h=(e,s,n)=>Te(e,typeof s!="symbol"?s+"":s,n);import{j as t,r as f,R as a}from"./iframe-nNwJoZIu.js";import{E as be,L as je,D as He}from"./LoadingProvider-BhcSkREB.js";import{a as me}from"./Card-CVeetA2w.js";import{C as Ce,S as pe,W as Ne}from"./CopyButton-CisoYug3.js";import{a as he}from"./higher_order-kYdajv6x.js";import{i as ue,k as ge}from"./typography-CjXOif4N.js";import{L as Se}from"./label-2TmJcdXx.js";import{T as m}from"./Text-BU7JBOLk.js";import{C as P}from"./NumberFormattersProvider-B0ToumS1.js";import"./CircularProgressIndicator-CqbENQDn.js";import"./ContainerLoading-DLJqZ6mq.js";import{u as xe,b as Pe,g as Ie,a as Ae,c as Ve,d as Be,e as we,f as Le}from"./SVGToolTip-DnPquoKG.js";import{A as j}from"./AffineTransform-DiV9SxhF.js";import{N as V}from"./NumberText-BVlmleFS.js";import"./ByteSizeText-CQe_WFuz.js";import{s as Ge}from"./base64-r9vyOGQT.js";/* empty css               */import"./CopyHex-Byy-hUKl.js";import"./DateTimeText-BP3eQbd8.js";import{C as fe}from"./DateTimeFormattersProvider-DlYJyFQm.js";import"./FullHexText-Cvhkr5BV.js";import"./HexText-CnWm4209.js";import"./MoneyText-BZoBvsl3.js";import"./RelativeTimeText-DwF5MhsZ.js";import"./TaggedBase64Text-DRHiObxy.js";import"./TimeText-cnSQtSPW.js";import{H as Re}from"./Heading2-BS2aGOdf.js";const De=ue("div"),We=e=>t.jsx(Se,{children:e.children}),Fe=e=>t.jsx(De,{className:"value",children:e.children}),H=({className:e,children:s,...n})=>t.jsxs("div",{...n,className:he(e,"value-labeled"),children:[t.jsx(Fe,{className:"value",children:s[0]},0),t.jsx(We,{className:"label",children:s[1]},1)]});try{H.displayName="ValueLabeled",H.__docgenInfo={description:`TabledLabeledValue is a component that is meant to display a label and
value pair of components, and lay them out depending on the screen size
of the device in question.

If on a sufficiently large device, they should appear side by side as
if in a full sized table element. Otherwise, they should appear as
a single element of sufficient size.`,displayName:"ValueLabeled",props:{className:{defaultValue:null,description:"",name:"className",required:!1,type:{name:"string"}}}}}catch{}const C=e=>f.useContext(P).variableBytes.format(e.bytes);try{C.displayName="VariableByteSizeText",C.__docgenInfo={description:"VariableByteSizeText is a simple Text element for rendering the bytes given\nin a localized format that can support variable notation for the bytes.\n\nIt achieves this by using the `variableBytes` formatter from the\n`CurrencyNumberFormatters` context.",displayName:"VariableByteSizeText",props:{bytes:{defaultValue:null,description:"",name:"bytes",required:!0,type:{name:"number"}}}}}catch{}const S=class S{constructor(s,n,r,o,i){h(this,"min");h(this,"max");h(this,"mean");h(this,"total");h(this,"count");h(this,"length");this.min=s,this.max=n,this.total=r,this.count=o,this.length=i,this.mean=r/o}get nullableMean(){return this.count===0?null:this.mean}static compute(s){return ze(s)}};h(S,"empty",new S(0,0,0,0,0));let u=S;function ze(e){const s=e.length;if(s===0)return new u(0,0,0,0,0);let n=null,r=null,o=0,i=0;for(let d=0;d<s;d++){const p=e[d];p!==null&&(i++,o+=p,(n===null||p<n)&&(n=p),(r===null||p>r)&&(r=p))}const l=n===r;return l&&n!==0&&(n=0),l&&r===0&&(r=1),new u(n??0,r??0,o??0,i,s)}const B=e=>t.jsx(V,{number:e.value});try{B.displayName="HistogramDefaultLabel",B.__docgenInfo={description:`HistogramDefaultLabel is a simple label for displaying a numeric value for
the histogram.  It is the default, which means it just renders the number
using the \`NumberText\` component.  If the axis needs to be labeled, then
the element should be specified.`,displayName:"HistogramDefaultLabel",props:{value:{defaultValue:null,description:"",name:"value",required:!0,type:{name:"number"}}}}}catch{}const Y=a.createContext(417),ke=a.createContext(152),x=a.createContext(360),g=a.createContext(152),I=a.createContext([]),$=a.createContext([]),_=a.createContext(u.empty),ye=a.createContext(u.empty),E=a.createContext([]),M=a.createContext(0),_e=a.createContext(0),O=a.createContext({x:0,y:0,width:0,height:0}),U=a.createContext(null),v=a.createContext(j.identity),qe=a.createContext(j.identity),X=a.createContext(B),Ye=16,K=24,Q=417,$e=176,w=e=>{const[s,n]=xe(),r=Math.floor((n==null?void 0:n.width)??Q),o=Math.floor(r*($e/Q));return t.jsx(Y.Provider,{value:r,children:t.jsx(ke.Provider,{value:o,children:t.jsx(x.Provider,{value:r-Ye,children:t.jsx(g.Provider,{value:o-K,children:t.jsx("svg",{ref:s,role:"graphics-datachart",viewBox:`0 0 ${r} ${o}`,children:t.jsx("g",{transform:`translate(0, ${K/2})`,children:e.children})})})})})})};try{w.displayName="HistogramBase",w.__docgenInfo={description:`HistogramBase is a component that provides the base SVG element for a
histogram.`,displayName:"HistogramBase",props:{}}}catch{}const Ee=ge("text"),L=({children:e})=>{const s=a.useContext(_),n=a.useContext(v),r=4,o=[],i=s.max/r;for(let l=0;l<=n.inputMax&&i>0;l+=i)o.push(l);return t.jsx(E.Provider,{value:o,children:e})},Me=60,G=()=>{const e=a.useContext(Y),s=a.useContext(g),n=a.useContext(v),r=a.useContext(E),o=a.useContext(U);return t.jsx("g",{className:"histogram-y-guide-lines",children:r.map((i,l)=>t.jsx("line",{role:"graphics-tick",x1:(o==null?void 0:o.width)??Me,y1:s-n.transform(i),x2:e,y2:s-n.transform(i)},l))})},R=e=>{const s=a.useContext(g),n=a.useContext(E),r=a.useContext(v),o=a.useContext(X);return t.jsx("g",{ref:e.labelsRef,className:"histogram-y-axis-labels",role:"graphics-category",children:n.map((i,l)=>t.jsx(Ee,{x:0,y:s-r.transform(i),dominantBaseline:"middle",className:"histogram-y-axis-label",children:a.createElement(o,{value:i})},l))})};try{L.displayName="ProvideGuideLines",L.__docgenInfo={description:`ProvideGuideLines is a component that calculates the y axis data spacing for
the histogram and provides.

It provides the following contexts:
- HistogramYAxisGuideLines

While consuming the following contexts:
- HistogramRangeStatistics
- HistogramRangeAffineTransform`,displayName:"ProvideGuideLines",props:{}}}catch{}try{G.displayName="HistogramGuideLines",G.__docgenInfo={description:`HistogramGuidLines is a component that displays the guide lines for the y-axis
based on the sampling provided for the histogram.

It is expected to have the following contexts set and provided for it:
- HistogramGraphWidth
- HistogramPlotHeight
- HistogramRangeAffineTransform
- HistogramYAxisGuideLines`,displayName:"HistogramGuideLines",props:{}}}catch{}try{R.displayName="HistogramYAxisLabels",R.__docgenInfo={description:`HistogramYAxisLabels is a component that displays the labels for the y-axis
based on the sampling provided for the histogram.

It is expected to have the following contexts set and provided for it:
- HistogramPlotHeight
- HistogramYAxisGuideLines
- HistogramRangeAffineTransform
- HistogramYAxisLabelComponent`,displayName:"HistogramYAxisLabels",props:{labelsRef:{defaultValue:null,description:"",name:"labelsRef",required:!0,type:{name:"RefObject<SVGSVGElement | null> | undefined"}}}}}catch{}const Z=e=>f.useContext(P).bytesPerSecond.format(e.bytesPerSecond);try{Z.displayName="BytesPerSecondText",Z.__docgenInfo={description:"BytesPerSecondText attempts to render the given value as a quantity\nof bytes per second.\n\nIt achieves this by using the `bytesPerSecond` formatter from the\n`CurrentNumberFormatters` context.",displayName:"BytesPerSecondText",props:{bytesPerSecond:{defaultValue:null,description:"",name:"bytesPerSecond",required:!0,type:{name:"number"}}}}}catch{}const ee=e=>{const s=Ge.encodeToString(e.value);return t.jsxs("span",{className:"inline",children:[e.children,t.jsx(Ce,{content:s})]})};try{ee.displayName="CopyBase64",ee.__docgenInfo={description:"CopyBase64 is a component that will display a `CopyButton` with the contents\nof the given ArrayBuffer given in the `value` automatically converted to a\nstandard encoding of base64 as the `content` of the `CopyButton` to be\ncopied into the end-users clipboard.",displayName:"CopyBase64",props:{value:{defaultValue:null,description:"",name:"value",required:!0,type:{name:"ArrayBuffer"}}}}}catch{}const te=e=>{const s=f.useContext(fe);return t.jsx("time",{title:s.utcFullDateTime.format(e.date),dateTime:e.date.toISOString(),children:s.friendly.format(e.date)})};try{te.displayName="FriendlyDateTimeText",te.__docgenInfo={description:`FriendlyDateTimeText is a Text component that renders the given Date using
the friendly date time format.`,displayName:"FriendlyDateTimeText",props:{date:{defaultValue:null,description:"",name:"date",required:!0,type:{name:"Date"}}}}}catch{}const se=e=>e.value.toString();try{se.displayName="FullTaggedBase64Text",se.__docgenInfo={description:`TaggedBase64Text is a simple Text component that renders a TaggedBase64 value
in it's own way.`,displayName:"FullTaggedBase64Text",props:{value:{defaultValue:null,description:"",name:"value",required:!0,type:{name:"TaggedBase64"}}}}}catch{}const ae=e=>f.useContext(P).percentage.format(e.percentage);try{ae.displayName="PercentageText",ae.__docgenInfo={description:"[PercentageText] is a component that will format the given `number` prop with\nthe percentage formatter retrieved from the `CurrentNumberFormatters` context.",displayName:"PercentageText",props:{percentage:{defaultValue:null,description:"",name:"percentage",required:!0,type:{name:"number"}}}}}catch{}const ne=e=>f.useContext(fe).seconds.format(e.seconds);try{ne.displayName="SecondsText",ne.__docgenInfo={description:`SecondsText attempts to render the given seconds into a single display that
indicates how many seconds it is representing.`,displayName:"SecondsText",props:{seconds:{defaultValue:null,description:"",name:"seconds",required:!0,type:{name:"number"}}}}}catch{}const re=e=>f.useContext(P).transactionsPerSecond.format(e.transactionsPerSecond);try{re.displayName="TransactionsPerSecondText",re.__docgenInfo={description:"TransactionsPerSecondText attempts to render the given value as a quantity\nof transactions per second.\n\nIt achieves this by using the `transactionsPerSecond` formatter from the\n`CurrentNumberFormatters` context.",displayName:"TransactionsPerSecondText",props:{transactionsPerSecond:{defaultValue:null,description:"",name:"transactionsPerSecond",required:!0,type:{name:"number"}}}}}catch{}const oe=ue("text"),ie=ge("text"),ce=10,Oe=2,b=14,le=14,D=()=>{const e=a.useContext(I).length,s=a.useContext(O),n=a.useContext(M),r=a.useContext(g),o=n/e,i=s.width/2;return t.jsx(Pe.Provider,{value:Xe,children:t.jsx(Ie.Provider,{value:Ue,children:t.jsx(Ae.Provider,{value:r,children:t.jsx(Ve.Provider,{value:s.x+i,children:t.jsx(Be.Provider,{value:s.y,children:t.jsx(we.Provider,{value:o,children:t.jsx(Le,{})})})})})})})},Ue=()=>{const e=a.useContext(O),s=e.width/2;return t.jsxs(t.Fragment,{children:[t.jsx("circle",{className:"value-pointer--outer",cx:e.x+s,cy:e.y,r:ce}),t.jsx("circle",{className:"value-pointer--inner",cx:e.x+s,cy:e.y,r:ce-Oe})]})},Xe=()=>{const e=a.useContext($),s=a.useContext(X),n=a.useContext(M),r=a.useContext(_e);return r===null?t.jsxs(t.Fragment,{children:[t.jsx(oe,{className:"tooltip--value-label",x:0,y:b,textAnchor:"start",children:t.jsx(m,{text:"Missing Data"})}),t.jsxs(ie,{className:"tooltip--value-label",x:0,y:b+le,textAnchor:"start",children:[t.jsx(m,{text:"Block "}),t.jsx(V,{number:Number(e[0])+n})]})]}):t.jsxs(t.Fragment,{children:[t.jsx(oe,{className:"tooltip--value-label",x:0,y:b,textAnchor:"start",children:a.createElement(s,{value:r})}),t.jsxs(ie,{className:"tooltip--value-label",x:0,y:b+le,textAnchor:"start",children:[t.jsx(m,{text:"Block "}),t.jsx(V,{number:Number(e[n])})]})]})};try{D.displayName="HistogramTooltip",D.__docgenInfo={description:"",displayName:"HistogramTooltip",props:{}}}catch{}const A=16,W=()=>{const e=a.useContext(Y),s=a.useContext(x),n=a.useContext(g),r=a.useContext(I),o=a.useContext(_),i=a.useContext(v);if(o.length===0)return t.jsx(t.Fragment,{});const l=(s-A-A)/o.length,d=Math.floor(l),p=d*o.length,T=r.map(y=>i.transform(Number(y))),J=e-p-A;return t.jsxs(t.Fragment,{children:[t.jsx("g",{className:"histogram-plot",transform:`translate(${J},0)`,role:"graphics-datagroup",children:r.map((y,c)=>y===null?t.jsx("rect",{role:"graphics-dataunit",className:"missing",x:c*d,y:0,width:d-1,height:n,"data-offset":c},`missing-${c}`):t.jsx("rect",{role:"graphics-dataunit",className:"bar",x:c*d,y:n-T[c],width:d-1,height:T[c],"data-offset":c},`bar-${c}`))}),t.jsx("g",{className:"histogram-plot",transform:`translate(${J},0)`,children:r.map((y,c)=>t.jsxs("g",{children:[t.jsx("rect",{className:"bbox",x:c*d,y:0,height:n,width:d}),t.jsx(_e.Provider,{value:y,children:t.jsx(M.Provider,{value:c,children:t.jsx(O.Provider,{value:{x:c*d,y:n-T[c],width:d,height:T[c]},children:t.jsx(D,{})})})})]},`tooltip-${c}`))})]})};try{W.displayName="HistogramPlot",W.__docgenInfo={description:`HistogramPlot is a component that takes the given data and creates
rectangles for it in relation to the statistics that it requires.
It is expected to have the following contexts set and provided for
it:

- HistogramGraphWidth
- HistogramPlotWidth
- HistogramPlotHeight
- HistogramRange
- HistogramRangeStatistics
- HistogramRangeAffineTransform`,displayName:"HistogramPlot",props:{}}}catch{}const F=({children:e})=>{const s=a.useContext(x),n=a.useContext(g),r=a.useContext(ye),o=a.useContext(_),i=new j(r.min,r.max,0,s),l=new j(0,o.max,0,n);return t.jsx(qe.Provider,{value:i,children:t.jsx(v.Provider,{value:l,children:e})})},z=({children:e})=>{const s=a.useContext($),n=a.useContext(I),r=u.compute(s),o=u.compute(n);return t.jsx(ye.Provider,{value:r,children:t.jsx(_.Provider,{value:o,children:e})})},k=()=>{const[e,s]=xe();return t.jsx(w,{children:t.jsx(U.Provider,{value:s,children:t.jsx(Je,{children:t.jsx(F,{children:t.jsxs(L,{children:[t.jsxs("g",{role:"graphics-axis",children:[t.jsx(G,{}),t.jsx(R,{labelsRef:e})]}),t.jsx(W,{})]})})})})})},Je=e=>{const s=a.useContext(x),n=a.useContext(U);return t.jsx(x.Provider,{value:Math.floor(s-((n==null?void 0:n.width)??0)),children:e.children})},q=()=>{const e=a.useContext(x),s=a.useContext(g),n=e/s;return t.jsx("div",{className:"histogram--placeholder",style:{paddingBottom:`${1/n*100}%`},children:t.jsx(pe,{})})};try{F.displayName="ProvideAffineTransforms",F.__docgenInfo={description:`ProvideAffineTransforms is a component that calculates the affineTransforms for
the domain and range of the histogram and provides them to its children.

It provides the following contexts:
- HistogramDomainAffineTransform
- HistogramRangeAffineTransform

It consumes the following contexts:
- HistogramPlotWidth
- HistogramPlotHeight
- HistogramDomainStatistics
 - HistogramRangeStatistics`,displayName:"ProvideAffineTransforms",props:{}}}catch{}try{z.displayName="ProvideDataStatistics",z.__docgenInfo={description:`ProvideDataStatistics is a component that calculates the statistics for the
domain and range of the histogram and provides them to its children.

It provides the following contexts:
- HistogramDomainStatistics
- HistogramRangeStatistics`,displayName:"ProvideDataStatistics",props:{}}}catch{}try{k.displayName="SimpleHistogram",k.__docgenInfo={description:"",displayName:"SimpleHistogram",props:{}}}catch{}try{q.displayName="SimpleHistogramPlaceholder",q.__docgenInfo={description:`SimpleHistogramPlaceholder is a placeholder component that is displayed when
the histogram is loading.`,displayName:"SimpleHistogramPlaceholder",props:{}}}catch{}const N=e=>t.jsxs("div",{className:he(e.className,"histogram-section-title"),children:[t.jsx(Re,{children:e.children[0]}),e.children[1]]});try{N.displayName="HistogramSectionTitle",N.__docgenInfo={description:`HistogramSectionTitle is a title element that is displayed above a histogram.
It is expected to label the histogram itself with a title, and have some data
next to it that shows some metric aggregation of the data from the histogram
itself.

Example:
+----------------------------------+
| Block time                 10.5s |
|                          Average |
+----------------------------------+`,displayName:"HistogramSectionTitle",props:{className:{defaultValue:null,description:"",name:"className",required:!1,type:{name:"string"}}}}}catch{}const Ke=Ne(me),Qe=()=>{const e=a.useContext(_);return Number.isNaN(e.mean)?t.jsx(m,{text:"-"}):t.jsx(C,{bytes:e.mean})},Ze=e=>Number.isNaN(e.value)?t.jsx(m,{text:"-"}):t.jsx(C,{bytes:e.value}),de=()=>{const e=a.useContext(be),s=a.useContext(je),n=a.useContext(He);return s?t.jsxs(Ke,{className:"block-size-histogram",children:[t.jsxs(N,{children:[t.jsx(m,{text:"Block size"}),t.jsxs(H,{children:[t.jsx(pe,{}),t.jsx(m,{text:"Average"})]})]}),t.jsx(q,{})]}):e?t.jsx(t.Fragment,{}):t.jsx(me,{className:"block-size-histogram",children:t.jsx(I.Provider,{value:n.blockSize,children:t.jsx($.Provider,{value:n.blocks,children:t.jsx(X.Provider,{value:Ze,children:t.jsxs(z,{children:[t.jsxs(N,{children:[t.jsx(m,{text:"Block size"}),t.jsxs(H,{children:[t.jsx(Qe,{}),t.jsx(m,{text:"Average"})]})]}),t.jsx(k,{})]})})})})})};try{de.displayName="BlockSizeHistogram",de.__docgenInfo={description:"",displayName:"BlockSizeHistogram",props:{}}}catch{}export{de as B,u as D,se as F,N as H,z as P,q as S,H as V,I as a,$ as b,X as c,k as d,Z as e,_ as f,ne as g,ae as h};
