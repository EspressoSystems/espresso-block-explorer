import{R as d,j as O}from"./iframe-D8Xp_xun.js";import{a as h}from"./assert-B20_bgky.js";class c{start;end;constructor(t,e){this.start=t,this.end=e}static empty=c.collapsed(-1);static collapsed(t){return new c(t,t)}get isCollapsed(){return this.start===this.end}get isNormalized(){return this.start<=this.end}get isValid(){return this.start>=0&&this.end>=0}textAfter(t){return h(this.isNormalized,"TextRange must be normalized"),t.slice(this.end)}textBefore(t){return h(this.isNormalized,"TextRange must be normalized"),t.slice(0,this.start)}textWithin(t){return h(this.isNormalized,"TextRange must be normalized"),t.slice(this.start,this.end)}isEquivalentTo(t){return this.start===t.start&&this.end===t.end}}class l extends c{baseOffset;extentOffset;isDirectional;constructor(t,e,n=!1){super(t<e?t:e,t<e?e:t),this.baseOffset=t,this.extentOffset=e,this.isDirectional=n}static collapsed(t){return new l(t,t)}static fromPosition(t){return new l(t,t)}copyWith({baseOffset:t=this.baseOffset,extentOffset:e=this.extentOffset,isDirectional:n=this.isDirectional}={}){return new l(t,e,n)}expandTo(t,e=!1){if(t>=this.start&&t<=this.end)return this;const n=this.baseOffset<this.extentOffset;return t<=this.start?e?this.copyWith({baseOffset:this.end,extentOffset:t}):this.copyWith({baseOffset:n?t:this.baseOffset,extentOffset:n?this.extentOffset:t}):e?this.copyWith({baseOffset:this.start,extentOffset:t}):this.copyWith({baseOffset:n?this.baseOffset:t,extentOffset:n?t:this.extentOffset})}extendTo(t){return this.extentOffset===t?this:this.copyWith({extentOffset:t})}isEquivalentTo(t){return super.isEquivalentTo(t)&&this.baseOffset===t.baseOffset&&this.extentOffset===t.extentOffset&&this.isDirectional===t.isDirectional}}class u{text;selection;composing;constructor(t,e=l.collapsed(-1),n=c.empty){this.text=t,this.selection=e,this.composing=n}copyWith({text:t=this.text,selection:e=this.selection,composing:n=this.composing}={}){return new u(t,e,n)}}function m(a){const t=a.selectionStart||0,e=a.selectionEnd||0;return a.selectionDirection==="backward"?new l(e,t,!0):new l(t,e,t!==e&&(a.selectionDirection||"none")!=="none")}function y(a){const t=a.selectionStart||0,e=a.selectionEnd||0;return t===e?c.empty:new c(t,e)}const g=a=>{const t=d.useRef(null),{value:e,onChange:n,...E}=a,[r,f]=d.useState(e??new u("")),s=e??r;if(d.useEffect(()=>{let i=f;if(s&&s.text!==r.text){i(s);return}const o=t.current;if(o&&r.selection.isValid&&!s.selection.isEquivalentTo(r.selection)){if(i(s),s.selection.baseOffset===s.selection.extentOffset){o.setSelectionRange(s.selection.start,s.selection.end,"none");return}o.setSelectionRange(s.selection.start,s.selection.end,s.selection.baseOffset<=s.selection.extentOffset?"forward":"backward");return}return()=>{i=()=>{}}},[s,r.selection,r.selection.end,r.selection.isDirectional,r.selection.isValid,r.selection.start,r.text]),t.current&&r.selection.isValid){const i=r.selection;t.current.setSelectionRange(i.start,i.end,i.start<=i.end?"forward":"backward")}return O.jsx("input",{ref:t,type:"text",...E,value:s.text,onChange:i=>{const o=new u(i.target.value,m(i.target));n&&n(i,o),!i.isDefaultPrevented()&&f(o)},onSelect:i=>{if(!t.current)return;const o=m(t.current),x=y(t.current);if(o.isEquivalentTo(s.selection)&&x.isEquivalentTo(s.composing))return;const p=s.copyWith({selection:o,composing:x});n&&n(i,p),!i.isDefaultPrevented()&&f(p)}})};try{g.displayName="TextEditing",g.__docgenInfo={description:`TextEditing is a ReactComponent that provides a text input field
with support for explicitly controlling the value and selection.
It uses the TextEditingValue and TextSelection types to manage
the text and selection state.

It is modelled after the TextEditingController in Flutter,`,displayName:"TextEditing",props:{value:{defaultValue:null,description:"",name:"value",required:!1,type:{name:"TextEditingValue"}},onChange:{defaultValue:null,description:"",name:"onChange",required:!1,type:{name:"((event: ChangeEvent<HTMLInputElement> | SyntheticEvent<HTMLInputElement, Event>, value: TextEditingValue) => void)"}}}}}catch{}export{u as T,g as a,l as b};
