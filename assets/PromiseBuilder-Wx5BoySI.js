var h=Object.defineProperty;var g=(e,t,r)=>t in e?h(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var o=(e,t,r)=>(g(e,typeof t!="symbol"?t+"":t,r),r);import{j as c}from"./jsx-runtime-5BUNAZ9W.js";import{r as d,R as m}from"./index-4g5l5LRQ.js";var i=(e=>(e[e.none=0]="none",e[e.waiting=1]="waiting",e[e.active=2]="active",e[e.done=3]="done",e))(i||{});class a{get connectionState(){return 0}get data(){}get error(){}get hasData(){return!1}get hasError(){return!1}static nothing(){return new y}static waiting(){return new S}static withData(t,r){return new f(t,r)}static withError(t,r){return new w(t,r)}}class y extends a{}class S extends a{get connectionState(){return 1}}class w extends a{constructor(r,n){super();o(this,"_connectionState");o(this,"_error");this._connectionState=r,this._error=n}get connectionState(){return this._connectionState}get error(){return this._error}get hasError(){return!0}}class f extends a{constructor(r,n){super();o(this,"_connectionState");o(this,"_data");this._connectionState=r,this._data=n}get connectionState(){return this._connectionState}get data(){return this._data}get hasData(){return!0}}const v=d.createContext(!1),u=e=>c(v.Provider,{value:e.loading,children:e.children});try{u.displayName="SetLoading",u.__docgenInfo={description:"",displayName:"SetLoading",props:{loading:{defaultValue:null,description:"",name:"loading",required:!0,type:{name:"boolean"}}}}}catch{}const x=d.createContext(null),l=e=>c(x.Provider,{value:e.error,children:e.children});try{l.displayName="SetError",l.__docgenInfo={description:"",displayName:"SetError",props:{error:{defaultValue:null,description:"",name:"error",required:!0,type:{name:"unknown"}}}}}catch{}const D=d.createContext(null),p=e=>c(D.Provider,{value:e.data,children:e.children});try{p.displayName="SetData",p.__docgenInfo={description:`SetData is a Components whose sole purpose is to populate a DataContext
with the provided data.  At such a level we are unable to make any
type assertion about the data being provided.`,displayName:"SetData",props:{data:{defaultValue:null,description:"",name:"data",required:!0,type:{name:"unknown"}}}}}catch{}const _=e=>{const t=e.promise,[r,n]=m.useState({promise:t,state:a.waiting()});return r.state.connectionState==i.waiting&&t.then(s=>n({promise:t,state:a.withData(i.done,s)}),s=>n({promise:t,state:a.withError(i.done,s)})),r.promise!==t&&n({promise:t,state:a.waiting()}),e.builder({snapshot:r.state})};try{_.displayName="PromiseBuilder",_.__docgenInfo={description:"",displayName:"PromiseBuilder",props:{promise:{defaultValue:null,description:"",name:"promise",required:!0,type:{name:"Promise<unknown>"}},builder:{defaultValue:null,description:"",name:"builder",required:!0,type:{name:"FC<PromiseBuilderBuilderProps<unknown>>"}}}}}catch{}export{i as C,D,_ as P,u as S,l as a,p as b};
