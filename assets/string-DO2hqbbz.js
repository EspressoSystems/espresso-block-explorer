import{c as d,d as b,b as p}from"./assert-B20_bgky.js";class k{breakpoint(){}}function x(){return new k}const N=x();function y(){N.breakpoint()}class a extends Error{key;haveType;constructor(e,o,t=`expected object with key: "${o}", instead found ${e}`){super(t),this.haveType=e,this.key=o,Object.freeze(this),y()}toJSON(){return{code:a.name,message:this.message,have:this.haveType,key:this.key}}}class i{encode(e){return this.encoder.convert(e)}decode(e){return this.decoder.convert(e)}}class s extends i{}function Z(r){return typeof r=="boolean"}function _(r){return typeof r=="number"}function u(r){return typeof r=="string"}function ee(r){return typeof r=="bigint"}function E(r){return typeof r=="object"&&r!==null}function j(r){return r!==void 0}function T(r,e){return Array.isArray(r)&&r.every(e)}function $(r){return e=>T(e,r)}function re(r,e,o){return E(r)&&e in r&&o(r[e])}function oe(r,...e){return E(r)&&e.every(o=>o in r)}function m(r,...e){if(typeof r!="object")throw new Error("expected object");if(r===null)throw new Error("received null");for(const o of e)if(!(o in r))throw new a("object",o)}function A(r,e){if(!u(r.code))throw new Error("code must be a string");if(r.code!==e)throw new Error(`expected code to be ${e}, got ${r.code}`)}function ne(r,e){if(!u(r.type))throw new Error("type must be a string");if(r.type!==e)throw new Error(`expected type to be ${e}, got ${r.type}`)}class v extends Error{constructor(e){super(e)}get code(){return this.constructor.name}toJSON(){return C.convert(this)}}class O{convert(e){return d(e,v),{code:e.code,message:e.message}}}const C=new O,S="NoCodecFoundError";class c extends Error{codec;constructor(e,o=`no codec found for: "${e}"`){super(o),this.codec=e,Object.freeze(this),y()}toJSON(){return{code:n.encode(c.name),message:n.encode(this.message),codec:n.encode(this.codec)}}get code(){return S}}const l=new Map;class I{convert(e){m(e,"code");const o=n.decode(e.code),t=l.get(o);if(!t)throw new c(o);return t.decode(e)}}class B{convert(e){const o=l.get(e.code);if(!o)throw new c(e.code);return o.encode(e)}}class D extends i{encoder=new B;decoder=new I}const te=new D;function R(r,e){l.set(r,e)}const w="InvalidTypeError";class h extends v{have;want;constructor(e,o,t=`invalid type: have "${e}", want "${o}"`){super(t),this.have=e,this.want=o,Object.freeze(this)}toJSON(){return g.encode(this)}get code(){return w}}class J{convert(e){return m(e,"code","have","want","message"),A(e,w),new h(n.decode(e.have),n.decode(e.want),n.decode(e.message))}}class U{convert(e){return d(e,h),{...C.convert(e),have:n.encode(e.have),want:n.encode(e.want)}}}class z extends s{encoder=new U;decoder=new J}const g=new z;R(w,g);const F=$(j);class K{convert(e){return e}}const f=new K;class M extends i{encoder=f;decoder=f}const se=new M;class W{itemCodec;constructor(e){this.itemCodec=e}convert(e){if(!F(e)){const o=typeof e=="object"&&e!==null?e.constructor.name:typeof e,t="array";throw new Error(`invalid array value: have "${o}", want "${t}"`)}return e.map(o=>this.itemCodec.decode(o))}}class q{itemCodec;constructor(e){this.itemCodec=e}convert(e){return d(e,Array),e.map(o=>this.itemCodec.encode(o))}}class G extends s{encoder;decoder;constructor(e,o){super(),this.encoder=o,this.decoder=e}}class H{itemCodec;constructor(e){this.itemCodec=e}convert(e){return e===null?null:this.itemCodec.decode(e)}}class L{itemCodec;constructor(e){this.itemCodec=e}convert(e){return e===null?null:(b(e),this.itemCodec.encode(e))}}class P extends s{encoder;decoder;constructor(e,o){super(),this.encoder=o,this.decoder=e}}class Q{convert(e){if(!u(e))throw new h(typeof e,"string");return e}}class V{convert(e){return p(e,"string"),e}}class X extends s{encoder=new V;decoder=new Q}const n=new X;new G(new W(n),new q(n));const ce=new P(new H(n),new L(n));function de(r){return!r||!r.trim()?null:r}export{G as A,v as B,i as C,h as I,P as N,s as T,O as a,m as b,A as c,y as d,C as e,_ as f,u as g,H as h,ee as i,L as j,W as k,q as l,ne as m,c as n,te as o,ce as p,de as q,R as r,n as s,oe as t,se as u,Z as v,F as w,re as x,j as y};
