import{j as t}from"./jsx-runtime-BlAj40OV.js";import{m as P,i as v,e as k,z as O,a as E,c as j}from"./functional-CfXZTWhy.js";import{c as H,L as u,e as m,D as c,f as h,h as $,m as F,C as S,d as U,n as X,i as Y,j as q,k as b,l as J,o as K,p as D}from"./constants-BINQQZyf.js";import{R as i}from"./index-Cs7sjTYM.js";import{M as f,a as Q,b as _,c as Z}from"./WorldMapDotsFullResolution-ki2WQQ9y.js";import{u as ee,b as oe,a as te,c as ne,d as re,e as ae,f as ie}from"./SVGToolTip-VtYDiDwI.js";import{L as se,D as ce}from"./LoadingProvider-Cf52ybPZ.js";import{l as de}from"./typography-BIj1kvXp.js";import{T}from"./Text-BU7JBOLk.js";import{A as le}from"./AsyncIterableResolver-CCfvgvmz.js";import{u as L,m as pe}from"./functional_async-mClN8vtW.js";import"./AffineTransform-DiV9SxhF.js";const I=e=>{const o=i.useContext(f),n=i.useContext(Q),d=new H(n.minOutput,n.maxOutput,new u(new m(new c(Number(o.y)+Number(o.width))),new h(o.x)),new u(new m(o.y),new h(new c(Number(o.x)+Number(o.width))))),r=new S(n,d),p=new S(U,r),s=new c(Number(o.width)*Number($)/Number(F)),a=new c(Number(s)/2),x=Array.from(P(v(X),N=>new m(new c(N*Number(s)+Number(a))))),l=Array.from(P(v(Y),N=>new h(new c(N*Number(s)+Number(a))))),V=Array.from(k(l,N=>P(x,B=>new u(B,N))));return t.jsx(_.Provider,{value:V,children:t.jsx(Z.Provider,{value:p,children:e.children})})};try{I.displayName="ProjectionProvider",I.__docgenInfo={description:`ProjectionProvider is a component that provides the necessary context for
the projection of geodesic coordinates to the coordinate space of the map.

The projection is computed from the desired size of the map and the desired
geodesic projection.  These are consumed from the following contexts:
- MapCoordinateSpaceRectContext
- MapGeodesicProjectionContext

This component is a provider for the following contexts:
- MapCoordinateGridSpaceCentersContext
- MapGeodesicToCoordinateSpaceProjectionContext`,displayName:"ProjectionProvider",props:{}}}catch{}function ue(e,o,n){return e.current===null||o===null||o.width<=0||o.height<=0?n:{x:new c(o.x),y:new c(o.y),width:new c(o.width),height:new c(o.height)}}const M=e=>{const o=i.useContext(f),[n,d]=ee(),r=ue(n,d,o);return t.jsx(f.Provider,{value:r,children:t.jsx("svg",{ref:n,viewBox:`${Number(r.x)} ${Number(r.y)} ${Number(r.x)+Number(r.width)} ${Number(r.y)+Number(r.height)}`,children:e.children})})};try{M.displayName="WorldMapAutoSizer",M.__docgenInfo={description:`WorldMapAutoSizer is a component that automatically sizes the world map
based on the size of the SVG element that it is rendered in.  It is a
provider for the MapCoordinateSpaceRectContext.`,displayName:"WorldMapAutoSizer",props:{}}}catch{}const A=de("text"),R=14,w=i.createContext(null),z=()=>{const e=i.useContext(f),o=i.useContext(se),n=i.useContext(ce)||[],d=i.useContext(_),r=Number(q)/Number(F)*Number(e.width);return o?t.jsx(t.Fragment,{}):t.jsxs(t.Fragment,{children:[t.jsx("svg",{className:"world-map-population-dots",viewBox:`${Number(e.x)} ${Number(e.y)} ${Number(e.x)+Number(e.width)} ${Number(e.y)+Number(e.height)}`,children:n.map((p,s)=>{const a=d[p.offset];return t.jsx("g",{children:t.jsx("circle",{className:"node",cx:Number(a.lng),cy:Number(a.lat),r:Number(r),"data-coord":b.inverseProject(a).toString(),"data-index":s})},s)})}),t.jsx("svg",{className:"world-map-population-dots-tooltips",viewBox:`${Number(e.x)} ${Number(e.y)} ${Number(e.x)+Number(e.width)} ${Number(e.y)+Number(e.height)}`,children:n.map((p,s)=>{const a=d[p.offset];return t.jsxs("g",{className:"population",children:[t.jsx("rect",{className:"node-hitbox",x:Number(a.lng)-Number(r),y:Number(a.lat)-Number(r),width:Number(r)*2,height:Number(r)*2,"data-coord":b.inverseProject(a).toString(),"data-index":s}),t.jsx(w.Provider,{value:p,children:t.jsx(me,{})})]},s)})})]})},me=()=>{const e=i.useContext(f),o=i.useContext(w),n=i.useContext(_);if(!o)return t.jsx(t.Fragment,{});const d=n[o.offset],r=Number(d.lng)/Number(e.width);return t.jsx(oe.Provider,{value:he,children:t.jsx(te.Provider,{value:Number(e.height),children:t.jsx(ne.Provider,{value:Number(d.lng),children:t.jsx(re.Provider,{value:Number(d.lat),children:t.jsx(ae.Provider,{value:r,children:t.jsx(ie,{})})})})})})},he=()=>{const e=i.useContext(w);return e?t.jsx(t.Fragment,{children:e.nodes.map((o,n)=>o.name===null?t.jsx(A,{x:0,y:R*(n+1),textAnchor:"center",children:t.jsx(T,{text:`unnamed node ${n+1}`})},n):t.jsx(A,{x:0,y:R*(n+1),textAnchor:"center",children:t.jsx(T,{text:o.name})},n))}):t.jsx(t.Fragment,{})};try{z.displayName="WorldMapDotsPopulationFullResolution",z.__docgenInfo={description:`WorldMapDotsPopulationFullResolution represents dots that are lit up based on
the containing coordinate box.  The dots are meant to represent the parts
of the world that have a node present.`,displayName:"WorldMapDotsPopulationFullResolution",props:{}}}catch{}const xe=i.createContext(L()),g=i.createContext(L());function C(e){const o=Number($)/2,n=O(E(),J,(s,a)=>{const x=new u(new m(new c(Number(a.lat)-o)),new h(new c(Number(a.lng)-o))),l=new u(new m(new c(Number(a.lat)+o)),new h(new c(Number(a.lng)+o)));return{offset:s,bbox:K([b.inverseProject(x),b.inverseProject(l)])}}),d=P(n,({offset:s,bbox:a})=>{const x=j(e,l=>l.location!==null&&l.location.coords!==null&&a.contains(new u(new m(new D(l.location.coords[0])),new h(new D(l.location.coords[1])))));return{offset:s,bbox:a,nodes:Array.from(x)}}),r=j(d,s=>s.nodes.length>0);return Array.from(r)}function y(e){return Promise.resolve(C(e))}const G=e=>{const o=i.useContext(xe),n=i.useMemo(()=>pe(o,y),[o]);return t.jsx(g.Provider,{value:n,children:e.children})},W=e=>{const o=i.useContext(g);return t.jsx(le,{asyncIterable:o,children:e.children})};try{C.displayName="convertNodeInformationToDotPopulation",C.__docgenInfo={description:`convertNodeInformationToDotPopulation is a function that takes in a list of
NodeSummaryData and converts it into a list of DotPopulation.  The DotPopulation
represents the nodes that are contained within the bounding boxes of the map grid.`,displayName:"convertNodeInformationToDotPopulation",props:{}}}catch{}try{y.displayName="convertNodeInformationToDotPopulationPromise",y.__docgenInfo={description:`convertNodeInformationToDotPopulationPromise is a function that takes in a
list of NodeSummaryData and converts it into a list of DotPopulation.`,displayName:"convertNodeInformationToDotPopulationPromise",props:{}}}catch{}try{g.displayName="DotPopulationStreamContext",g.__docgenInfo={description:`DotPopulationStreamContext is a context that provides an AsyncIterable of
DotPopulation.  The DotPopulation represents the nodes that are contained
within the bounding boxes of the map grid.`,displayName:"DotPopulationStreamContext",props:{}}}catch{}try{G.displayName="NodeInformationToDotPopulation",G.__docgenInfo={description:`NodeInformationToDotPopulation is a component that takes in a stream of
a list of NodeSummaryData and converts it into a stream of a list of
DotPopulation.  The DotPopulation represents the nodes that are contained
within the bounding boxes of the map grid.`,displayName:"NodeInformationToDotPopulation",props:{}}}catch{}try{W.displayName="DotPopulationStreamConsumer",W.__docgenInfo={description:`DotPopulationStreamConsumer is a component that consumes the
DotPopulationStreamContext.  It does this via the AsyncIterableResolver
component. The children of this component can retrieve the DotPopulation
via the contexts provided by the AsyncIterableResolver.`,displayName:"DotPopulationStreamConsumer",props:{}}}catch{}export{W as D,xe as N,I as P,M as W,G as a,z as b};
