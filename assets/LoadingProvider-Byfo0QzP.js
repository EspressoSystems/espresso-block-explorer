var v=Object.defineProperty;var b=(e,t,r)=>t in e?v(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var l=(e,t,r)=>b(e,typeof t!="symbol"?t+"":t,r);import{r as o,j as s,R as d}from"./iframe-DygLW6I0.js";import{M as h}from"./MissingElementError-BiJAxgGE.js";import{U as w}from"./UnimplementedError-N0odIfDD.js";const E=o.createContext(null),y=e=>s.jsx(E.Provider,{value:e.data,children:e.children});try{y.displayName="SetData",y.__docgenInfo={description:`SetData is a Components whose sole purpose is to populate a DataContext
with the provided data.  At such a level we are unable to make any
type assertion about the data being provided.`,displayName:"SetData",props:{data:{defaultValue:null,description:"",name:"data",required:!0,type:{name:"unknown"}}}}}catch{}class C{constructor(t,r){l(this,"value");l(this,"next");this.value=t,this.next=r}[Symbol.iterator](){return _(this)}}function A(e,t){return new C(t,e)}function*_(e){if(e!==null)for(let t=e;t!==null;t=t.next)yield t.value}async function*S(e){for(let t=e.next();!t.done;t=e.next())yield t.value}function H(e){return S(e[Symbol.iterator]())}async function*g(e){for(let t=await e.next();!t.done;t=await e.next())yield t.value}async function*k(e,t){for(let r=await e.next();!r.done;r=await e.next())t(r.value)&&(yield r.value)}function K(e,t){return k(e[Symbol.asyncIterator](),t)}async function*N(e,t){for(let r=await e.next();!r.done;r=await e.next())yield await t(r.value)}function O(e,t){return N(e[Symbol.asyncIterator](),t)}async function*L(e,t){for(let r=0;r<t;r++){const n=await e.next();if(n.done)return;yield n.value}}function Q(e,t){return L(e[Symbol.asyncIterator](),t)}async function*j(e,t){for(let r=await e.next();!r.done&&t(r.value);r=await e.next())yield r.value}function X(e,t){return j(e[Symbol.asyncIterator](),t)}async function*D(e,t){for(let r=0;r<t;r++)if((await e.next()).done)return;yield*g(e)}function Y(e,t){return D(e[Symbol.asyncIterator](),t)}async function P(e){const t=await e.next();if(t.done)throw new h;return t.value}async function Z(e){return P(e[Symbol.asyncIterator]())}async function J(e,t){for(let r=await e.next();!r.done;r=await e.next())if(t(r.value))return r.value}async function $(e,t){return J(e[Symbol.asyncIterator](),t)}async function R(e){let t;for(let r=await e.next();!r.done;r=await e.next())t=r.value;if(t===void 0)throw new h;return t}async function ee(e){return R(e[Symbol.asyncIterator]())}async function*T(e,t){for(let r=await e.next();!r.done;r=await e.next())yield*t(r.value)}function te(e,t){return T(e[Symbol.asyncIterator](),t)}async function q(e,t,r){const n=r;let i=t;for(let c=await n.next();!c.done;c=await n.next())i=e(await i,c.value);return i}async function*W(e){let t=null;for(let r=await e.next();!r.done;r=await e.next())t=A(t,r.value);yield*_(t)}function re(e){return W(e[Symbol.asyncIterator]())}function V(e){return q(async(t,r)=>(t.push(r),t),Promise.resolve([]),e)}async function ne(e){return V(e[Symbol.asyncIterator]())}async function*ae(){throw new w}async function*z(){}const a=o.createContext(null),u=o.createContext(z()),p=e=>s.jsx(a.Provider,{value:e.error,children:e.children}),I=o.createContext(null),f=e=>{const t=d.useContext(a);return s.jsx(I.Provider,{value:t,children:e.children})},x=e=>{const t=d.useContext(a),r=d.useContext(I);return s.jsx(a.Provider,{value:t??r,children:e.children})};try{a.displayName="ErrorContext",a.__docgenInfo={description:`ErrorContext is a React Context that is used to store and make available
any error present in the component tree.`,displayName:"ErrorContext",props:{}}}catch{}try{u.displayName="ErrorStreamContext",u.__docgenInfo={description:`ErrorStreamContext is similar to ErrorContext, however it is potentially
updatable.`,displayName:"ErrorStreamContext",props:{}}}catch{}try{p.displayName="SetError",p.__docgenInfo={description:"",displayName:"SetError",props:{error:{defaultValue:null,description:"",name:"error",required:!0,type:{name:"unknown"}}}}}catch{}try{f.displayName="ErrorCarry",f.__docgenInfo={description:`ErrorCarry is a helper component that is provided in order to carry an
error from the error context, and assign it to a new context.  This is
helpful since ErrorContext is overwritten by any downstream error that
is encountered.

This can be used in conjunction with ErrorJoiner to combine errors from
different contexts.`,displayName:"ErrorCarry",props:{}}}catch{}try{x.displayName="ErrorJoiner",x.__docgenInfo={description:`ErrorJoiner is a helper component that is able to combine errors from
teh ErrorCarry component, and the original ErrorContext that is encountered.
This will prioritize the error from the ErrorContext, and then fall back
to the error provided by the ErrorCarry component.`,displayName:"ErrorJoiner",props:{}}}catch{}const M=o.createContext(!1),m=e=>s.jsx(M.Provider,{value:e.loading,children:e.children});try{m.displayName="SetLoading",m.__docgenInfo={description:"",displayName:"SetLoading",props:{loading:{defaultValue:null,description:"",name:"loading",required:!0,type:{name:"boolean"}}}}}catch{}export{u as A,H as B,E as D,a as E,M as L,m as S,p as a,y as b,f as c,x as d,D as e,P as f,Z as g,Y as h,N as i,V as j,j as k,te as l,O as m,k as n,re as o,ee as p,X as q,W as r,$ as s,L as t,ae as u,K as v,ne as w,Q as x,R as y,z};
