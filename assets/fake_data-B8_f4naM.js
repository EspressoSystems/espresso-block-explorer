import{j as o,R as i,r as he}from"./iframe-BYhJ0elB.js";import{a as ge,E as fe}from"./environment_banner-B4t9GNlA.js";import{E as ce}from"./espresso-CLfCnmfa.js";import{d as m,a as S}from"./assert-B20_bgky.js";import{C as A,D as Te,n as G,F as we,G as be,I as ke,J as ve,K as xe}from"./en_US-KAK2ZBDO-FQI910wT.js";import{h as u}from"./array_buffer-CXxOH-jd.js";import{b as h}from"./bigint-Rw5otYDY.js";import"./string-DO2hqbbz.js";import{c as f}from"./wallet_address-Bz0sM43W.js";import"./UnimplementedError-BGJ4_cDZ.js";import{f as H,n as Ce,m as B,e as se,o as Se,h as Me}from"./functional-By_9lidy.js";import"./base64-Dpbg5EzT.js";import"./url-BkzmLfUb.js";import"./blocks-CwOn2-KH.js";import{n as k}from"./nodes-TxP0qWmy.js";import{S as Ee,e as Ae,a as _e,w as Be,b as de,c as le,L as R,E as ne,d as Ie,R as Ne,f as Pe,V as C,g as Re,U as Ve}from"./stake_table_contract_context-8fhQ-B42.js";import"./explorer-9dy3tY29.js";const v=[{type:"constructor",inputs:[],stateMutability:"nonpayable"},{type:"function",name:"DEFAULT_ADMIN_ROLE",inputs:[],outputs:[{name:"",type:"bytes32",internalType:"bytes32"}],stateMutability:"view"},{type:"function",name:"PAUSER_ROLE",inputs:[],outputs:[{name:"",type:"bytes32",internalType:"bytes32"}],stateMutability:"view"},{type:"function",name:"UPGRADE_INTERFACE_VERSION",inputs:[],outputs:[{name:"",type:"string",internalType:"string"}],stateMutability:"view"},{type:"function",name:"_hashBlsKey",inputs:[{name:"blsVK",type:"tuple",internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]}],outputs:[{name:"",type:"bytes32",internalType:"bytes32"}],stateMutability:"pure"},{type:"function",name:"activeStake",inputs:[],outputs:[{name:"",type:"uint256",internalType:"uint256"}],stateMutability:"view"},{type:"function",name:"blsKeys",inputs:[{name:"blsKeyHash",type:"bytes32",internalType:"bytes32"}],outputs:[{name:"used",type:"bool",internalType:"bool"}],stateMutability:"view"},{type:"function",name:"claimValidatorExit",inputs:[{name:"validator",type:"address",internalType:"address"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"claimWithdrawal",inputs:[{name:"validator",type:"address",internalType:"address"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"commissionTracking",inputs:[{name:"validator",type:"address",internalType:"address"}],outputs:[{name:"commission",type:"uint16",internalType:"uint16"},{name:"lastIncreaseTime",type:"uint256",internalType:"uint256"}],stateMutability:"view"},{type:"function",name:"delegate",inputs:[{name:"validator",type:"address",internalType:"address"},{name:"amount",type:"uint256",internalType:"uint256"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"delegations",inputs:[{name:"validator",type:"address",internalType:"address"},{name:"delegator",type:"address",internalType:"address"}],outputs:[{name:"amount",type:"uint256",internalType:"uint256"}],stateMutability:"view"},{type:"function",name:"deregisterValidator",inputs:[],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"exitEscrowPeriod",inputs:[],outputs:[{name:"",type:"uint256",internalType:"uint256"}],stateMutability:"view"},{type:"function",name:"getRoleAdmin",inputs:[{name:"role",type:"bytes32",internalType:"bytes32"}],outputs:[{name:"",type:"bytes32",internalType:"bytes32"}],stateMutability:"view"},{type:"function",name:"getVersion",inputs:[],outputs:[{name:"majorVersion",type:"uint8",internalType:"uint8"},{name:"minorVersion",type:"uint8",internalType:"uint8"},{name:"patchVersion",type:"uint8",internalType:"uint8"}],stateMutability:"pure"},{type:"function",name:"grantRole",inputs:[{name:"role",type:"bytes32",internalType:"bytes32"},{name:"account",type:"address",internalType:"address"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"hasRole",inputs:[{name:"role",type:"bytes32",internalType:"bytes32"},{name:"account",type:"address",internalType:"address"}],outputs:[{name:"",type:"bool",internalType:"bool"}],stateMutability:"view"},{type:"function",name:"initialize",inputs:[{name:"_tokenAddress",type:"address",internalType:"address"},{name:"_lightClientAddress",type:"address",internalType:"address"},{name:"_exitEscrowPeriod",type:"uint256",internalType:"uint256"},{name:"_timelock",type:"address",internalType:"address"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"initializeV2",inputs:[{name:"pauser",type:"address",internalType:"address"},{name:"admin",type:"address",internalType:"address"},{name:"initialActiveStake",type:"uint256",internalType:"uint256"},{name:"initialCommissions",type:"tuple[]",internalType:"struct StakeTableV2.InitialCommission[]",components:[{name:"validator",type:"address",internalType:"address"},{name:"commission",type:"uint16",internalType:"uint16"}]}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"initializedAtBlock",inputs:[],outputs:[{name:"",type:"uint256",internalType:"uint256"}],stateMutability:"view"},{type:"function",name:"lightClient",inputs:[],outputs:[{name:"",type:"address",internalType:"contract ILightClient"}],stateMutability:"view"},{type:"function",name:"maxCommissionIncrease",inputs:[],outputs:[{name:"",type:"uint16",internalType:"uint16"}],stateMutability:"view"},{type:"function",name:"minCommissionIncreaseInterval",inputs:[],outputs:[{name:"",type:"uint256",internalType:"uint256"}],stateMutability:"view"},{type:"function",name:"owner",inputs:[],outputs:[{name:"",type:"address",internalType:"address"}],stateMutability:"view"},{type:"function",name:"pause",inputs:[],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"paused",inputs:[],outputs:[{name:"",type:"bool",internalType:"bool"}],stateMutability:"view"},{type:"function",name:"proxiableUUID",inputs:[],outputs:[{name:"",type:"bytes32",internalType:"bytes32"}],stateMutability:"view"},{type:"function",name:"registerValidator",inputs:[{name:"",type:"tuple",internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]},{name:"",type:"tuple",internalType:"struct EdOnBN254.EdOnBN254Point",components:[{name:"x",type:"uint256",internalType:"uint256"},{name:"y",type:"uint256",internalType:"uint256"}]},{name:"",type:"tuple",internalType:"struct BN254.G1Point",components:[{name:"x",type:"uint256",internalType:"BN254.BaseField"},{name:"y",type:"uint256",internalType:"BN254.BaseField"}]},{name:"",type:"uint16",internalType:"uint16"}],outputs:[],stateMutability:"pure"},{type:"function",name:"registerValidatorV2",inputs:[{name:"blsVK",type:"tuple",internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrVK",type:"tuple",internalType:"struct EdOnBN254.EdOnBN254Point",components:[{name:"x",type:"uint256",internalType:"uint256"},{name:"y",type:"uint256",internalType:"uint256"}]},{name:"blsSig",type:"tuple",internalType:"struct BN254.G1Point",components:[{name:"x",type:"uint256",internalType:"BN254.BaseField"},{name:"y",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrSig",type:"bytes",internalType:"bytes"},{name:"commission",type:"uint16",internalType:"uint16"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"renounceOwnership",inputs:[],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"renounceRole",inputs:[{name:"role",type:"bytes32",internalType:"bytes32"},{name:"callerConfirmation",type:"address",internalType:"address"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"revokeRole",inputs:[{name:"role",type:"bytes32",internalType:"bytes32"},{name:"account",type:"address",internalType:"address"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"schnorrKeys",inputs:[{name:"schnorrKey",type:"bytes32",internalType:"bytes32"}],outputs:[{name:"used",type:"bool",internalType:"bool"}],stateMutability:"view"},{type:"function",name:"setMaxCommissionIncrease",inputs:[{name:"newMaxIncrease",type:"uint16",internalType:"uint16"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"setMinCommissionUpdateInterval",inputs:[{name:"newInterval",type:"uint256",internalType:"uint256"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"supportsInterface",inputs:[{name:"interfaceId",type:"bytes4",internalType:"bytes4"}],outputs:[{name:"",type:"bool",internalType:"bool"}],stateMutability:"view"},{type:"function",name:"token",inputs:[],outputs:[{name:"",type:"address",internalType:"contract ERC20"}],stateMutability:"view"},{type:"function",name:"transferOwnership",inputs:[{name:"newOwner",type:"address",internalType:"address"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"undelegate",inputs:[{name:"validator",type:"address",internalType:"address"},{name:"amount",type:"uint256",internalType:"uint256"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"undelegations",inputs:[{name:"validator",type:"address",internalType:"address"},{name:"delegator",type:"address",internalType:"address"}],outputs:[{name:"amount",type:"uint256",internalType:"uint256"},{name:"unlocksAt",type:"uint256",internalType:"uint256"}],stateMutability:"view"},{type:"function",name:"unpause",inputs:[],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"updateCommission",inputs:[{name:"newCommission",type:"uint16",internalType:"uint16"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"updateConsensusKeys",inputs:[{name:"",type:"tuple",internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]},{name:"",type:"tuple",internalType:"struct EdOnBN254.EdOnBN254Point",components:[{name:"x",type:"uint256",internalType:"uint256"},{name:"y",type:"uint256",internalType:"uint256"}]},{name:"",type:"tuple",internalType:"struct BN254.G1Point",components:[{name:"x",type:"uint256",internalType:"BN254.BaseField"},{name:"y",type:"uint256",internalType:"BN254.BaseField"}]}],outputs:[],stateMutability:"pure"},{type:"function",name:"updateConsensusKeysV2",inputs:[{name:"blsVK",type:"tuple",internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrVK",type:"tuple",internalType:"struct EdOnBN254.EdOnBN254Point",components:[{name:"x",type:"uint256",internalType:"uint256"},{name:"y",type:"uint256",internalType:"uint256"}]},{name:"blsSig",type:"tuple",internalType:"struct BN254.G1Point",components:[{name:"x",type:"uint256",internalType:"BN254.BaseField"},{name:"y",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrSig",type:"bytes",internalType:"bytes"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"updateExitEscrowPeriod",inputs:[{name:"newExitEscrowPeriod",type:"uint64",internalType:"uint64"}],outputs:[],stateMutability:"nonpayable"},{type:"function",name:"upgradeToAndCall",inputs:[{name:"newImplementation",type:"address",internalType:"address"},{name:"data",type:"bytes",internalType:"bytes"}],outputs:[],stateMutability:"payable"},{type:"function",name:"validatorExits",inputs:[{name:"validator",type:"address",internalType:"address"}],outputs:[{name:"unlocksAt",type:"uint256",internalType:"uint256"}],stateMutability:"view"},{type:"function",name:"validators",inputs:[{name:"account",type:"address",internalType:"address"}],outputs:[{name:"delegatedAmount",type:"uint256",internalType:"uint256"},{name:"status",type:"uint8",internalType:"enum StakeTable.ValidatorStatus"}],stateMutability:"view"},{type:"event",name:"CommissionUpdated",inputs:[{name:"validator",type:"address",indexed:!0,internalType:"address"},{name:"timestamp",type:"uint256",indexed:!1,internalType:"uint256"},{name:"oldCommission",type:"uint16",indexed:!1,internalType:"uint16"},{name:"newCommission",type:"uint16",indexed:!1,internalType:"uint16"}],anonymous:!1},{type:"event",name:"ConsensusKeysUpdated",inputs:[{name:"account",type:"address",indexed:!0,internalType:"address"},{name:"blsVK",type:"tuple",indexed:!1,internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrVK",type:"tuple",indexed:!1,internalType:"struct EdOnBN254.EdOnBN254Point",components:[{name:"x",type:"uint256",internalType:"uint256"},{name:"y",type:"uint256",internalType:"uint256"}]}],anonymous:!1},{type:"event",name:"ConsensusKeysUpdatedV2",inputs:[{name:"account",type:"address",indexed:!0,internalType:"address"},{name:"blsVK",type:"tuple",indexed:!1,internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrVK",type:"tuple",indexed:!1,internalType:"struct EdOnBN254.EdOnBN254Point",components:[{name:"x",type:"uint256",internalType:"uint256"},{name:"y",type:"uint256",internalType:"uint256"}]},{name:"blsSig",type:"tuple",indexed:!1,internalType:"struct BN254.G1Point",components:[{name:"x",type:"uint256",internalType:"BN254.BaseField"},{name:"y",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrSig",type:"bytes",indexed:!1,internalType:"bytes"}],anonymous:!1},{type:"event",name:"Delegated",inputs:[{name:"delegator",type:"address",indexed:!0,internalType:"address"},{name:"validator",type:"address",indexed:!0,internalType:"address"},{name:"amount",type:"uint256",indexed:!1,internalType:"uint256"}],anonymous:!1},{type:"event",name:"ExitEscrowPeriodUpdated",inputs:[{name:"newExitEscrowPeriod",type:"uint64",indexed:!1,internalType:"uint64"}],anonymous:!1},{type:"event",name:"Initialized",inputs:[{name:"version",type:"uint64",indexed:!1,internalType:"uint64"}],anonymous:!1},{type:"event",name:"MaxCommissionIncreaseUpdated",inputs:[{name:"newMaxIncrease",type:"uint16",indexed:!1,internalType:"uint16"}],anonymous:!1},{type:"event",name:"MinCommissionUpdateIntervalUpdated",inputs:[{name:"newInterval",type:"uint256",indexed:!1,internalType:"uint256"}],anonymous:!1},{type:"event",name:"OwnershipTransferred",inputs:[{name:"previousOwner",type:"address",indexed:!0,internalType:"address"},{name:"newOwner",type:"address",indexed:!0,internalType:"address"}],anonymous:!1},{type:"event",name:"Paused",inputs:[{name:"account",type:"address",indexed:!1,internalType:"address"}],anonymous:!1},{type:"event",name:"RoleAdminChanged",inputs:[{name:"role",type:"bytes32",indexed:!0,internalType:"bytes32"},{name:"previousAdminRole",type:"bytes32",indexed:!0,internalType:"bytes32"},{name:"newAdminRole",type:"bytes32",indexed:!0,internalType:"bytes32"}],anonymous:!1},{type:"event",name:"RoleGranted",inputs:[{name:"role",type:"bytes32",indexed:!0,internalType:"bytes32"},{name:"account",type:"address",indexed:!0,internalType:"address"},{name:"sender",type:"address",indexed:!0,internalType:"address"}],anonymous:!1},{type:"event",name:"RoleRevoked",inputs:[{name:"role",type:"bytes32",indexed:!0,internalType:"bytes32"},{name:"account",type:"address",indexed:!0,internalType:"address"},{name:"sender",type:"address",indexed:!0,internalType:"address"}],anonymous:!1},{type:"event",name:"Undelegated",inputs:[{name:"delegator",type:"address",indexed:!0,internalType:"address"},{name:"validator",type:"address",indexed:!0,internalType:"address"},{name:"amount",type:"uint256",indexed:!1,internalType:"uint256"}],anonymous:!1},{type:"event",name:"Unpaused",inputs:[{name:"account",type:"address",indexed:!1,internalType:"address"}],anonymous:!1},{type:"event",name:"Upgraded",inputs:[{name:"implementation",type:"address",indexed:!0,internalType:"address"}],anonymous:!1},{type:"event",name:"ValidatorExit",inputs:[{name:"validator",type:"address",indexed:!0,internalType:"address"}],anonymous:!1},{type:"event",name:"ValidatorRegistered",inputs:[{name:"account",type:"address",indexed:!0,internalType:"address"},{name:"blsVk",type:"tuple",indexed:!1,internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrVk",type:"tuple",indexed:!1,internalType:"struct EdOnBN254.EdOnBN254Point",components:[{name:"x",type:"uint256",internalType:"uint256"},{name:"y",type:"uint256",internalType:"uint256"}]},{name:"commission",type:"uint16",indexed:!1,internalType:"uint16"}],anonymous:!1},{type:"event",name:"ValidatorRegisteredV2",inputs:[{name:"account",type:"address",indexed:!0,internalType:"address"},{name:"blsVK",type:"tuple",indexed:!1,internalType:"struct BN254.G2Point",components:[{name:"x0",type:"uint256",internalType:"BN254.BaseField"},{name:"x1",type:"uint256",internalType:"BN254.BaseField"},{name:"y0",type:"uint256",internalType:"BN254.BaseField"},{name:"y1",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrVK",type:"tuple",indexed:!1,internalType:"struct EdOnBN254.EdOnBN254Point",components:[{name:"x",type:"uint256",internalType:"uint256"},{name:"y",type:"uint256",internalType:"uint256"}]},{name:"commission",type:"uint16",indexed:!1,internalType:"uint16"},{name:"blsSig",type:"tuple",indexed:!1,internalType:"struct BN254.G1Point",components:[{name:"x",type:"uint256",internalType:"BN254.BaseField"},{name:"y",type:"uint256",internalType:"BN254.BaseField"}]},{name:"schnorrSig",type:"bytes",indexed:!1,internalType:"bytes"}],anonymous:!1},{type:"event",name:"Withdrawal",inputs:[{name:"account",type:"address",indexed:!0,internalType:"address"},{name:"amount",type:"uint256",indexed:!1,internalType:"uint256"}],anonymous:!1},{type:"error",name:"AccessControlBadConfirmation",inputs:[]},{type:"error",name:"AccessControlUnauthorizedAccount",inputs:[{name:"account",type:"address",internalType:"address"},{name:"neededRole",type:"bytes32",internalType:"bytes32"}]},{type:"error",name:"AddressEmptyCode",inputs:[{name:"target",type:"address",internalType:"address"}]},{type:"error",name:"BLSSigVerificationFailed",inputs:[]},{type:"error",name:"BN254PairingProdFailed",inputs:[]},{type:"error",name:"BlsKeyAlreadyUsed",inputs:[]},{type:"error",name:"CommissionAlreadyInitialized",inputs:[{name:"validator",type:"address",internalType:"address"}]},{type:"error",name:"CommissionIncreaseExceedsMax",inputs:[]},{type:"error",name:"CommissionUnchanged",inputs:[]},{type:"error",name:"CommissionUpdateTooSoon",inputs:[]},{type:"error",name:"DeprecatedFunction",inputs:[]},{type:"error",name:"ERC1967InvalidImplementation",inputs:[{name:"implementation",type:"address",internalType:"address"}]},{type:"error",name:"ERC1967NonPayable",inputs:[]},{type:"error",name:"EnforcedPause",inputs:[]},{type:"error",name:"ExitEscrowPeriodInvalid",inputs:[]},{type:"error",name:"ExpectedPause",inputs:[]},{type:"error",name:"FailedInnerCall",inputs:[]},{type:"error",name:"InitialActiveStakeExceedsBalance",inputs:[]},{type:"error",name:"InsufficientAllowance",inputs:[{name:"",type:"uint256",internalType:"uint256"},{name:"",type:"uint256",internalType:"uint256"}]},{type:"error",name:"InsufficientBalance",inputs:[{name:"",type:"uint256",internalType:"uint256"}]},{type:"error",name:"InvalidCommission",inputs:[]},{type:"error",name:"InvalidG1",inputs:[]},{type:"error",name:"InvalidInitialization",inputs:[]},{type:"error",name:"InvalidRateLimitParameters",inputs:[]},{type:"error",name:"InvalidSchnorrSig",inputs:[]},{type:"error",name:"InvalidSchnorrVK",inputs:[]},{type:"error",name:"NotInitializing",inputs:[]},{type:"error",name:"NothingToWithdraw",inputs:[]},{type:"error",name:"OwnableInvalidOwner",inputs:[{name:"owner",type:"address",internalType:"address"}]},{type:"error",name:"OwnableUnauthorizedAccount",inputs:[{name:"account",type:"address",internalType:"address"}]},{type:"error",name:"PowPrecompileFailed",inputs:[]},{type:"error",name:"PrematureWithdrawal",inputs:[]},{type:"error",name:"SchnorrKeyAlreadyUsed",inputs:[]},{type:"error",name:"UUPSUnauthorizedCallContext",inputs:[]},{type:"error",name:"UUPSUnsupportedProxiableUUID",inputs:[{name:"slot",type:"bytes32",internalType:"bytes32"}]},{type:"error",name:"UndelegationAlreadyExists",inputs:[]},{type:"error",name:"ValidatorAlreadyExited",inputs:[]},{type:"error",name:"ValidatorAlreadyRegistered",inputs:[]},{type:"error",name:"ValidatorInactive",inputs:[]},{type:"error",name:"ValidatorNotExited",inputs:[]},{type:"error",name:"ZeroAddress",inputs:[]},{type:"error",name:"ZeroAmount",inputs:[]}];class Fe extends Ee{constructor(e,t,n){super(e,t,n)}async updateConsensusKeysV2(e,t,n,a,r){return Ae(this.config,{account:e,abi:v,address:this.address,chainId:this.chainID,functionName:"updateConsensusKeysV2",args:[t,n,a,r]})}}class Ue extends _e{constructor(e,t,n){super(e,t,n)}async PAUSER_ROLE(){return A(this.config,{abi:v,address:this.address,chainId:this.chainID,functionName:"PAUSER_ROLE"})}async minCommissionIncreaseInterval(){return A(this.config,{abi:v,address:this.address,chainId:this.chainID,functionName:"minCommissionIncreaseInterval"})}async maxCommissionIncrease(){return A(this.config,{abi:v,address:this.address,chainId:this.chainID,functionName:"maxCommissionIncrease"})}async activeStake(){return A(this.config,{abi:v,address:this.address,chainId:this.chainID,functionName:"activeStake"})}async commissionTracking(e){return A(this.config,{abi:v,address:this.address,chainId:this.chainID,functionName:"commissionTracking",args:[e]})}async updateConsensusKeysV2(e,t,n,a){return Be(this.config,{abi:v,address:this.address,chainId:this.chainID,functionName:"updateConsensusKeysV2",args:[e,t,n,a]})}}const K=i.createContext(null),O=i.createContext(null),re=({children:s})=>o.jsx(Ke,{children:s}),Ke=({children:s})=>{const e=Te(),t=i.useContext(ce),n=t?.stakeTableContractAddress?new Ue(e,e.chains[0].id,t.stakeTableContractAddress):null,a=t?.stakeTableContractAddress?new Fe(e,e.chains[0].id,t.stakeTableContractAddress):null;return o.jsx(de.Provider,{value:n,children:o.jsx(le.Provider,{value:a,children:o.jsx(K.Provider,{value:n,children:o.jsx(O.Provider,{value:a,children:s})})})})};try{K.displayName="StakeTableV2ContractContext",K.__docgenInfo={description:`StakeTableV2ContractContext is a React context that provides
the Stake Table V2 contract instance.`,displayName:"StakeTableV2ContractContext",props:{}}}catch{}try{O.displayName="StakeTableV2ContractGasEstimatorContext",O.__docgenInfo={description:`StakeTableV2ContractGasEstimatorContext is a React context that provides
the Stake Table V2 contract gas estimator instance.`,displayName:"StakeTableV2ContractGasEstimatorContext",props:{}}}catch{}try{re.displayName="ProvideStakeTableV2Contract",re.__docgenInfo={description:`ProvideStakeTableV2Contract is a React component that provides
the Stake Table V2 contract via StakeTableV2ContractContext.`,displayName:"ProvideStakeTableV2Contract",props:{}}}catch{}class Oe{async transfer(){return 12345n}async approve(){return 12345n}async transferFrom(){return 12345n}}function pe(s,e,t){const n=f("keccak256"),a=new TextEncoder;n.update(a.encode("Transfer").buffer),n.update(a.encode(String(s)).buffer),n.update(a.encode(String(e)).buffer);for(const r of t)n.update(a.encode(r.hash).buffer);return u.encode(n.digest())}class T{constructor(e,t=null){this.storage=e,this.accountAddress=t}replaceAccountAddress(e){return new T(this.storage,e)}setAccountAddress(e){this.accountAddress=e}async getBalance(e){const t=e.address,n=this.storage.balances.get(t)??0n;return{decimals:18,formatted:String(n),symbol:"ESP",value:n}}async estimateFeesPerGas(){return{maxPriorityFeePerGas:1000000000n,maxFeePerGas:15000000000n,formatted:{maxPriorityFeePerGas:"1",maxFeePerGas:"15"}}}async estimateGas(){return 1000000000n}receiptFromTransactionAndBlock(e,t){const n=t.transactions.reduce((a,r)=>a+r.gas,0n);return{chainId:31337,blockHash:t.hash,blockNumber:t.height,contractAddress:e.contractAddress,cumulativeGasUsed:n,effectiveGasPrice:1n,from:e.transaction.from,gasUsed:n,logs:[],logsBloom:"0x",status:"success",to:e.transaction.to,transactionHash:e.hash,transactionIndex:t.transactions.findIndex(a=>a.hash===e.hash),type:"legacy"}}async getTransactionReceipt(e){const t=e.hash,n=this.storage.transactions.get(t);if(!n)throw new Error("Transaction not found");const a=this.storage.transactionToBlockMap.get(t)??null;if(!a)throw new Error("Block height not found");const r=this.storage.blocks[Number(a)];if(!r)throw new Error("Block not found");return this.receiptFromTransactionAndBlock(n,r)}transactionFromTransactionAndBlock(e,t){return t?{chainId:31337,gasPrice:1n,blockNumber:e.blockHeight,blockHash:t.hash,transactionIndex:t.transactions.findIndex(n=>n.hash===e.hash),from:this.accountAddress??"0x00000000000000000000000000000000",to:e.contractAddress??"0x00000000000000000000000000000000",gas:e.gas,hash:e.hash,input:"0x",nonce:0,r:"0x",s:"0x",v:0n,type:"legacy",typeHex:"0x1",value:e.value}:{chainId:31337,gasPrice:1n,from:this.accountAddress??"0x00000000000000000000000000000000",to:e.contractAddress??"0x00000000000000000000000000000000",gas:e.gas,hash:e.hash,input:"0x",nonce:0,r:"0x",s:"0x",v:0n,type:"legacy",typeHex:"0x1",value:e.value}}async getTransaction(e){const t=e.hash;if(!t)throw new Error("Transaction hash is required");const n=this.storage.transactions.get(t);if(!n){const r=this.storage.pendingTransactions.find(c=>c.hash===t);if(!r)throw new Error("Transaction not found");return this.transactionFromTransactionAndBlock(r,null)}const a=this.storage.blocks[Number(n.blockHeight)];return this.transactionFromTransactionAndBlock(n,a)}blockHeightFromTag(e="latest"){switch(e){case"latest":return this.storage.pendingBlockHeight-1n;case"earliest":return 0n;case"pending":return this.storage.pendingBlockHeight;case"safe":return this.storage.pendingBlockHeight>30n?0n:this.storage.pendingBlockHeight-30n;case"finalized":return this.storage.pendingBlockHeight>60n?0n:this.storage.pendingBlockHeight-60n;default:throw new Error("Unsupported blockTag")}}blockHeightFromGetBlockParameters(e){const t=e?.blockNumber??null;return t!==null?t:this.blockHeightFromTag(e?.blockTag??"latest")}blockFromBlock(e,t=!1){const n=e.transactions.reduce((r,c)=>r+c.gas,0n),a=t?e.transactions.map(r=>this.transactionFromTransactionAndBlock(r,e)):e.transactions.map(r=>r.hash);return{chainId:31337,baseFeePerGas:1n,blobGasUsed:0n,excessBlobGas:0n,difficulty:0n,extraData:"0x",logsBloom:"0x",gasLimit:n,gasUsed:n,miner:"0x",mixHash:"0x",number:e.height,hash:e.hash,nonce:"0x",parentHash:e.parentHash,receiptsRoot:"0x",sealFields:[],sha3Uncles:"0x",size:0n,stateRoot:"0x",timestamp:e.timestamp,totalDifficulty:null,transactions:a,transactionsRoot:"0x",uncles:[],withdrawals:[]}}async getBlock(e){const t=this.blockHeightFromGetBlockParameters(e),n=this.storage.blocks[Number(t)];if(!n)throw new Error("Block not found");return this.blockFromBlock(n,e?.includeTransactions)}async getBlockNumber(e){return this.blockHeightFromTag(e?.blockTag)}transactionCallBack=null;setTransactionCallback(e){this.transactionCallBack=e}mockWriteContractStorage(e,t){this.storage.contractStorage.set(e,t)}mockReadContractStorage(e){return this.storage.contractStorage.get(e)}mockWriteTransaction(e){const t=e.hash(),n={hash:t,blockHeight:this.storage.pendingBlockHeight,transaction:e,from:e.from,to:e.to,value:e.value,gas:e.gas};this.storage.transactions.set(t,n),this.storage.pendingTransactions.push(n)}mockBlockByHeight(e){return this.storage.blocks[Number(e)]??null}mockLatestBlock(){return this.storage.blocks[this.storage.blocks.length-1]}mockBlockByHash(e){return this.storage.hashToBlockMap.get(e)??null}mockTransactionsForBlockHash(e){const t=this.storage.hashToBlockMap.get(e);return t?t.transactions:null}mockAdvanceBlock(){const e=BigInt(Math.floor(Date.now()/1e3)),t=this.storage.pendingBlockHeight,n=pe(t,e,this.storage.pendingTransactions),a=this.storage.pendingTransactions;this.storage.pendingBlockHeight++,this.storage.pendingTransactions=[];const r=this.storage.blocks[this.storage.blocks.length-1],c={hash:n,parentHash:r.hash,height:t,timestamp:e,transactions:a};this.storage.blocks.push(c),this.storage.hashToBlockMap.set(n,c);for(const l of this.storage.contractStorage.keys()){const d=this.storage.contractStorage.get(l);m(d);const p=H((M,E)=>M.applyTransaction(E.transaction),d,a);this.storage.contractStorage.set(l,p)}for(const l of c.transactions)this.storage.transactionToBlockMap.set(l.hash,c.height),this.transactionCallBack&&this.transactionCallBack.l1Transaction(l.transaction)}}function De(s={}){const e={hash:pe(0n,0n,[]),parentHash:"0x0000000000000000000000000000000000000000000000000000000000000000",height:0n,transactions:[],timestamp:0n},[t]=i.useState({balances:s.balances??new Map,transactions:s.transactions??new Map,accountAddress:s.accountAddress??null,pendingBlockHeight:s.pendingBlockHeight??1n,pendingTransactions:s.pendingTransactions??[],transactionToBlockMap:s.transactionToBlockMap??new Map,blocks:s.blocks??[e],hashToBlockMap:s.hashToBlockMap??new Map([[e.hash,e]]),contractStorage:s.contractStorage??new Map});return t}const L=({interval:s,children:e})=>{const t=s??12e3,n=i.useContext(R);return i.useEffect(()=>{let a=()=>{n instanceof T&&n.mockAdvanceBlock()};const r=setInterval(a,t);return()=>{clearInterval(r),a=()=>{}}},[n,t]),e},W=({children:s})=>{const e=De(),[t]=i.useState(new T(e)),n=i.useContext(G);return i.useEffect(()=>(t.setAccountAddress(n),()=>{}),[t,n]),o.jsx(R.Provider,{value:t,children:s})};try{L.displayName="ProvideAutoAdvanceL1Methods",L.__docgenInfo={description:"",displayName:"ProvideAutoAdvanceL1Methods",props:{interval:{defaultValue:null,description:"",name:"interval",required:!1,type:{name:"number"}}}}}catch{}try{W.displayName="MockL1Methods",W.__docgenInfo={description:`MockESPTokenContract is a React component that provides
a mock ESPTokenContract implementation via context for
testing and development purposes.

It will overwrite the ESPTokenContractContext with a mock
implementation that simulates the behavior of an actual
ESPTokenContract.`,displayName:"MockL1Methods",props:{}}}catch{}const I="0xdeadc0dedeadc0dedeadc0dedeadc0dedeadc0de",Ge={address:I,displayName:"mocked_account.eth",hasPendingTransactions:!1},oe={id:31337,hasIcon:!1};function He(){const[s,e]=he.useState({account:null,chain:null});return{openAccountModal:()=>{e(t=>({...t,account:null,chain:null}))},openChainModal:()=>{e(t=>({...t,chain:oe}))},openConnectModal:()=>{e(t=>({...t,account:Ge,chain:oe}))},accountModalOpen:!1,chainModalOpen:!1,connectModalOpen:!1,account:s.account,chain:s.chain,authenticationStatus:s.account===null?"unauthenticated":"authenticated"}}const z=({children:s})=>{const{openAccountModal:e,openChainModal:t,openConnectModal:n,accountModalOpen:a,chainModalOpen:r,connectModalOpen:c,account:l,chain:d,authenticationStatus:p}=He();return o.jsx(we.Provider,{value:!0,children:o.jsx(be.Provider,{value:{openAccountModal:e,openChainModal:t,openConnectModal:n,accountModalOpen:a,chainModalOpen:r,connectModalOpen:c},children:o.jsx(ke,{value:l??null,children:o.jsx(ve.Provider,{value:d??null,children:o.jsx(xe.Provider,{value:p??null,children:s})})})})})};try{I.displayName="MockAddress",I.__docgenInfo={description:`MockAddress is a predefined mock address used in the
MockRainbowKit component.`,displayName:"MockAddress",props:{}}}catch{}try{z.displayName="MockRainbowKit",z.__docgenInfo={description:`MockRainbowKit is a React component that provides
mock implementations of RainbowKit contexts for testing
and development purposes.

When it comes to testing UI / UX and layout of current designs, it is
helpful to have a mock implementation of RainbowKit components available
and ready to use in order to generate a predefined controllable state.

Such configurations allow for the accounting of various edge cases
and scenarios that may arise during actual usage of the application.`,displayName:"MockRainbowKit",props:{}}}catch{}class w{constructor(e,t,n,a,r,c,l,d,p){this.contractAddress=e,this.version=t,this.name=n,this.symbol=a,this.decimals=r,this.totalSupply=c,this.balances=l,this.allowances=d,this.lastUpdate=p}applyTransaction(e){if(e instanceof N){const t=e.applyToState(this);return new w(t.contractAddress,t.version,t.name,t.symbol,t.decimals,t.totalSupply,t.balances,t.allowances,new Date)}return this}}function j(s,e){const t=s.mockReadContractStorage(V)??null;m(t),e.applyToState(t),s.mockWriteTransaction(e)}class N{contractAddress;ts=new Date}class D extends N{constructor(e,t,n,a){super(),this.contractAddress=e,this.from=t,this.to=n,this.value=a,this.from=t,this.to=n,this.value=a}gas=21000n;hash(){const e=f("keccak256"),t=new TextEncoder;return e.update(t.encode("Transfer").buffer),e.update(t.encode(this.ts.toISOString()).buffer),e.update(t.encode(this.from).buffer),e.update(t.encode(this.to).buffer),e.update(t.encode(h.encoder.convert(this.value)).buffer),u.encode(e.digest())}applyToState(e){const t=new Map(e.balances),n=t.get(this.from)??0n,a=t.get(this.to)??0n;return t.set(this.from,n-this.value),t.set(this.to,a+this.value),new w(e.contractAddress,e.version,e.name,e.symbol,e.decimals,e.totalSupply,t,e.allowances,e.lastUpdate)}}class q extends N{constructor(e,t,n,a){super(),this.contractAddress=e,this.owner=t,this.spender=n,this.value=a,this.owner=t,this.spender=n,this.value=a}gas=21000n;get from(){return this.owner}get to(){return this.spender}hash(){const e=f("keccak256"),t=new TextEncoder;return e.update(t.encode("Approve").buffer),e.update(t.encode(this.ts.toISOString()).buffer),e.update(t.encode(this.owner).buffer),e.update(t.encode(this.spender).buffer),e.update(t.encode(h.encoder.convert(this.value)).buffer),u.encode(e.digest())}applyToState(e){const t=new Map(e.allowances),n=new Map(t.get(this.owner)??new Map);return n.set(this.spender,this.value),t.set(this.owner,n),new w(e.contractAddress,e.version,e.name,e.symbol,e.decimals,e.totalSupply,e.balances,t,e.lastUpdate)}}const V=Symbol("MockTokenContract");class g{constructor(e,t,n=null){this.l1Methods=e,this.accountAddress=n,this.l1Methods.mockReadContractStorage(V)||this.l1Methods.mockWriteContractStorage(V,new w(t.contractAddress,t.version,t.name,t.symbol,t.decimals,t.totalSupply,t.balances,t.allowances,t.lastUpdate)),this.accountAddress=n}get state(){const e=this.l1Methods.mockReadContractStorage(V)??null;return m(e),e}replaceAccountAddress(e){return new g(this.l1Methods,this.state,e)}setAccountAddress(e){this.accountAddress=e}get lastUpdate(){return this.state.lastUpdate}get address(){return this.state.contractAddress}async getVersion(){return this.state.version}async name(){return this.state.name}async symbol(){return this.state.symbol}async decimals(){return this.state.decimals}async totalSupply(){return this.state.totalSupply}async balanceOf(e){return this.state.balances.get(e)??0n}async allowance(e,t){return this.state.allowances.get(e)?.get(t)??0n}async transfer(e,t){if(!this.accountAddress)throw new Error("No account address available for transfer.");const n=this.accountAddress;if(t<0n)throw new Error("Transfer value cannot be negative.");if(t>await this.balanceOf(n))throw new Error("Insufficient balance for transfer.");const a=new D(this.address,n,e,t);return j(this.l1Methods,a),a.hash()}async approve(e,t){if(!this.accountAddress)throw new Error("No account address available for approve.");const n=new q(this.address,this.accountAddress,e,t);return j(this.l1Methods,n),n.hash()}async transferFrom(e,t,n){if(n<0n)throw new Error("Transfer value cannot be negative.");if(await this.allowance(e,t)<n)throw new Error("Insufficient allowance for transfer.");if(n>await this.balanceOf(e))throw new Error("Insufficient balance for transfer.");const r=new D(this.address,e,t,n);return j(this.l1Methods,r),r.hash()}}function je(s){const e="0x0000000000000000000000000000000000000001",[t]=i.useState(new w(e,[1,0,0],"Espresso Token","ESP",18,12345678900n*10n**18n,new Map([[I,5000000000000000000000n],["0x0000000000000000000000000000000000000002",H((n,a)=>n+a.stake,0n,k)],["0x0000000000000000000000000000000000000003",1000000000000000000000000000n]]),new Map,new Date));return t}const Z=({children:s})=>{const e=i.useContext(R),t=je(),n=i.useContext(G);S(e instanceof T);const[a]=i.useState(new g(e,t));if(i.useEffect(()=>(a.setAccountAddress(n),()=>{}),[a,n]),!(e instanceof T))throw new Error("MockESPTokenContract requires MockL1MethodsImpl");return o.jsx(ne.Provider,{value:a,children:o.jsx(Ie.Provider,{value:new Oe,children:s})})};try{w.displayName="MockESPTokenContractState",w.__docgenInfo={description:`MockESPTokenContractState defines the structure of the mock
ESPTokenContract state.

This state is meant to simulate the behavior of an actual ESPTokenContract
for testing and development purposes. It's implementations may not be
accurate to the live contract, and are only intended to provide
a reasonable facsimile for UI and interaction testing.`,displayName:"MockESPTokenContractState",props:{}}}catch{}try{N.displayName="ESPTokenContractStateAction",N.__docgenInfo={description:`ESPTokenContractStateAction is an abstract base class
representing an action that modifies the state of the
MockESPTokenContract.`,displayName:"ESPTokenContractStateAction",props:{}}}catch{}try{D.displayName="TransferBalance",D.__docgenInfo={description:`TransferBalance represents a token transfer action
within the MockESPTokenContract.`,displayName:"TransferBalance",props:{}}}catch{}try{q.displayName="ApproveAllowance",q.__docgenInfo={description:`ApproveAllowance represents an approval action
within the MockESPTokenContract.`,displayName:"ApproveAllowance",props:{}}}catch{}try{g.displayName="MockESPTokenContractImpl",g.__docgenInfo={description:`MockESPTokenContractImpl is a mock implementation of the ESPTokenContract
interface for testing and development purposes.

It simulates the behavior of an actual ESPTokenContract by maintaining
an internal state and providing methods to interact with that state.
This is done to simulate some consistency of the expected behavior of the
real contract without needing to connect to a live blockchain.`,displayName:"MockESPTokenContractImpl",props:{}}}catch{}try{Z.displayName="MockESPTokenContract",Z.__docgenInfo={description:`MockESPTokenContract is a React component that provides
a mock ESPTokenContract implementation via context for
testing and development purposes.

It will overwrite the ESPTokenContractContext with a mock
implementation that simulates the behavior of an actual
ESPTokenContract.`,displayName:"MockESPTokenContract",props:{}}}catch{}class Le{async claimRewards(){return 100005n}}class x{constructor(e,t,n){this.contractAddress=e,this.claimedRewards=t,this.lastUpdate=n}applyTransaction(e){if(e instanceof ue){const t=e.applyToState(this);return new x(t.contractAddress,t.claimedRewards,new Date)}return this}}function We(s,e){const t=s.mockReadContractStorage(F)??null;m(t),e.applyToState(t),s.mockWriteTransaction(e)}const F=Symbol("RewardClaimStorage");class ue{contractAddress;ts=new Date}class ze extends ue{constructor(e,t,n,a){super(),this.contractAddress=e,this.delegator=t,this.lifetimeRewards=n,this.authData=a}gas=21000n;get from(){return this.contractAddress}get to(){return this.delegator}get value(){return this.lifetimeRewards}hash(){const e=f("keccak256"),t=new TextEncoder;return e.update(t.encode("ClaimReward").buffer),e.update(t.encode(this.ts.toISOString()).buffer),e.update(t.encode(this.delegator).buffer),e.update(t.encode(h.encoder.convert(this.lifetimeRewards)).buffer),u.encode(e.digest())}applyToState(e){const t=new Map(e.claimedRewards);return t.set(this.delegator,this.lifetimeRewards),new x(e.contractAddress,t,e.lastUpdate)}}class ae{constructor(e,t,n,a=null){this.l1Methods=e,this.espToken=t,this.accountAddress=a,this.l1Methods.mockReadContractStorage(F)||this.l1Methods.mockWriteContractStorage(F,new x(n.contractAddress,n.claimedRewards,n.lastUpdate)),this.accountAddress=a,this.espToken=t.replaceAccountAddress(n.contractAddress)}get state(){const e=this.l1Methods.mockReadContractStorage(F)??null;return m(e),e}replaceAccountAddress(e){return new ae(this.l1Methods,this.espToken,this.state,e)}setAccountAddress(e){this.accountAddress=e}get lastUpdate(){return this.state.lastUpdate}get address(){return this.state.contractAddress}async claimedRewards(e){return this.state.claimedRewards.get(e)??0n}async getVersion(){return[1,0,0]}async claimRewards(e,t){if(!this.accountAddress)throw new Error("no active account detected");const n=await this.claimedRewards(this.accountAddress),a=e-n;if(a<0n)throw new Error("lifetimeRewards cannot be less than previously claimed rewards");this.espToken.transfer(this.accountAddress,a);const r=new ze(this.address,this.accountAddress,e,t);return We(this.l1Methods,r),r.hash()}}function qe(s){const e="0x0000000000000000000000000000000000000003",[t]=i.useState(new x(e,new Map,new Date));return t}const $=({children:s})=>{const e=i.useContext(R),t=i.useContext(ne),n=qe(),a=i.useContext(G);S(e instanceof T),S(t instanceof g);const[r]=i.useState(()=>new ae(e,t,n));return i.useEffect(()=>(r.setAccountAddress(a),()=>{}),[r,a]),o.jsx(Ne.Provider,{value:r,children:o.jsx(Pe.Provider,{value:new Le,children:s})})};try{x.displayName="MockRewardClaimState",x.__docgenInfo={description:`RewardClaimState defines the structure of the mock
RewardClaimContract state.`,displayName:"MockRewardClaimState",props:{}}}catch{}try{$.displayName="MockRewardClaimContract",$.__docgenInfo={description:`MockRewardClaimContract is a React component that provides
a mock RewardClaimContract implementation via context for
testing and development purposes.

It will overwrite the RewardClaimContractContext with a mock
implementation that simulates the behavior of an actual
RewardClaimContract.`,displayName:"MockRewardClaimContract",props:{}}}catch{}class Ze{async deregisterValidator(){return 100001n}async delegate(){return 69144n}async undelegate(){return 89736n}async claimWithdrawal(){return 100002n}async claimValidatorExit(){return 100003n}async updateConsensusKeysV2(){return 100004n}}class y{constructor(e,t,n,a,r,c,l,d,p,M,E,ye,me){this.contractAddress=e,this.validators=t,this.blsKeys=n,this.validatorExits=a,this.delegations=r,this.undelegations=c,this.exitEscrowPeriod=l,this.pauserRole=d,this.minCommissionIncreaseInterval=p,this.maxCommissionIncrease=M,this.commissionTracking=E,this.schnorrKeys=ye,this.lastUpdate=me}applyTransaction(e){if(e instanceof b){const t=e.applyToState(this);return new y(t.contractAddress,t.validators,t.blsKeys,t.validatorExits,t.delegations,t.undelegations,t.exitEscrowPeriod,t.pauserRole,t.minCommissionIncreaseInterval,t.maxCommissionIncrease,t.commissionTracking,t.schnorrKeys,new Date)}return this}}class b{contractAddress;ts=new Date}function _(s,e){const t=s.mockReadContractStorage(U)??null;m(t),e.applyToState(t),s.mockWriteTransaction(e)}class J extends b{constructor(e,t,n,a){super(),this.contractAddress=e,this.validator=t,this.delegator=n,this.amount=a}gas=100000n;get from(){return this.delegator}get to(){return this.contractAddress}get value(){return this.amount}hash(){const e=f("keccak256"),t=new TextEncoder;return e.update(t.encode("Delegate").buffer),e.update(t.encode(this.ts.toISOString()).buffer),e.update(t.encode(this.validator).buffer),e.update(t.encode(this.delegator).buffer),e.update(t.encode(h.encoder.convert(this.amount)).buffer),u.encode(e.digest())}applyToState(e){const t=new Map(e.delegations),n=new Map(t.get(this.validator)??new Map),a=new Map(e.validators),r=a.get(this.validator)??[0n,0],c=n.get(this.delegator)??0n;return n.set(this.delegator,c+this.amount),t.set(this.validator,n),a.set(this.validator,[r[0]+this.amount,r[1]]),new y(e.contractAddress,a,e.blsKeys,e.validatorExits,t,e.undelegations,e.exitEscrowPeriod,e.pauserRole,e.minCommissionIncreaseInterval,e.maxCommissionIncrease,e.commissionTracking,e.schnorrKeys,e.lastUpdate)}}class X extends b{constructor(e,t,n,a,r){super(),this.contractAddress=e,this.validator=t,this.delegator=n,this.amount=a,this.exitEscrowPeriod=r}gas=100000n;get from(){return this.delegator}get to(){return this.contractAddress}get value(){return this.amount}hash(){const e=f("keccak256"),t=new TextEncoder;return e.update(t.encode("Undelegate").buffer),e.update(t.encode(this.ts.toISOString()).buffer),e.update(t.encode(this.validator).buffer),e.update(t.encode(this.delegator).buffer),e.update(t.encode(h.encoder.convert(this.amount)).buffer),e.update(t.encode(h.encoder.convert(this.exitEscrowPeriod)).buffer),u.encode(e.digest())}applyToState(e){const t=new Map(e.delegations),n=new Map(t.get(this.validator)??new Map),a=n.get(this.delegator)??0n,r=new Map(e.validators);n.set(this.delegator,a-this.amount),t.set(this.validator,n);const c=r.get(this.validator)??[0n,0];r.set(this.validator,[c[0]-this.amount,c[1]]);const l=new Map(e.undelegations),d=new Map(l.get(this.validator)??new Map);return d.set(this.delegator,[this.amount,BigInt(this.ts.valueOf())+e.exitEscrowPeriod]),l.set(this.validator,d),new y(e.contractAddress,r,e.blsKeys,e.validatorExits,t,l,e.exitEscrowPeriod,e.pauserRole,e.minCommissionIncreaseInterval,e.maxCommissionIncrease,e.commissionTracking,e.schnorrKeys,e.lastUpdate)}}class Q extends b{constructor(e,t,n,a){super(),this.contractAddress=e,this.validator=t,this.delegator=n,this.amount=a}gas=100000n;get from(){return this.delegator}get to(){return this.contractAddress}get value(){return this.amount}hash(){const e=f("keccak256"),t=new TextEncoder;return e.update(t.encode("ClaimWithdrawal").buffer),e.update(t.encode(this.ts.toISOString()).buffer),e.update(t.encode(this.validator).buffer),e.update(t.encode(this.delegator).buffer),e.update(t.encode(h.encoder.convert(this.amount)).buffer),u.encode(e.digest())}applyToState(e){const t=new Map(e.undelegations),n=new Map(t.get(this.validator)??new Map);return n.delete(this.delegator),t.set(this.validator,n),new y(e.contractAddress,e.validators,e.blsKeys,e.validatorExits,e.delegations,t,e.exitEscrowPeriod,e.pauserRole,e.minCommissionIncreaseInterval,e.maxCommissionIncrease,e.commissionTracking,e.schnorrKeys,e.lastUpdate)}}class Y extends b{constructor(e,t,n,a){super(),this.contractAddress=e,this.validator=t,this.delegator=n,this.amount=a}gas=100000n;get from(){return this.delegator}get to(){return this.contractAddress}get value(){return this.amount}hash(){const e=f("keccak256"),t=new TextEncoder;return e.update(t.encode("ClaimValidatorExit").buffer),e.update(t.encode(this.ts.toISOString()).buffer),e.update(t.encode(this.validator).buffer),e.update(t.encode(this.delegator).buffer),e.update(t.encode(h.encoder.convert(this.amount)).buffer),u.encode(e.digest())}applyToState(e){const t=new Map(e.validatorExits);t.delete(this.validator);const n=new Map(e.delegations),a=new Map(n.get(this.validator)??new Map);return a.delete(this.delegator),n.set(this.validator,a),new y(e.contractAddress,e.validators,e.blsKeys,t,n,e.undelegations,e.exitEscrowPeriod,e.pauserRole,e.minCommissionIncreaseInterval,e.maxCommissionIncrease,e.commissionTracking,e.schnorrKeys,e.lastUpdate)}}class ee extends b{constructor(e,t,n){super(),this.contractAddress=e,this.validator=t,this.exitTime=n}gas=100000n;get from(){return this.validator}get to(){return this.contractAddress}value=0n;hash(){const e=f("keccak256"),t=new TextEncoder;return e.update(t.encode("ValidatorExit").buffer),e.update(t.encode(this.ts.toISOString()).buffer),e.update(t.encode(this.validator).buffer),e.update(t.encode(h.encoder.convert(this.exitTime)).buffer),u.encode(e.digest())}applyToState(e){const t=new Map(e.validatorExits);t.set(this.validator,this.exitTime);const n=new Map(e.validators),a=n.get(this.validator)??[0n,0];return n.set(this.validator,[a[0],C.exited]),new y(e.contractAddress,n,e.blsKeys,t,e.delegations,e.undelegations,e.exitEscrowPeriod,e.pauserRole,e.minCommissionIncreaseInterval,e.maxCommissionIncrease,e.commissionTracking,e.schnorrKeys,e.lastUpdate)}}const U=Symbol("StakeTableStorage");class P{constructor(e,t,n,a){this.l1Methods=e,this.espToken=t,this.accountAddress=a,t instanceof g&&(this.espToken=t.replaceAccountAddress(n.contractAddress)),this.l1Methods.mockReadContractStorage(U)||this.l1Methods.mockWriteContractStorage(U,n),this.accountAddress=a}get state(){const e=this.l1Methods.mockReadContractStorage(U)??null;return m(e),e}replaceAccountAddress(e){return new P(this.l1Methods,this.espToken,this.state,e)}setAccountAddress(e){this.accountAddress=e}get lastUpdate(){return this.state.lastUpdate}get address(){return this.state.contractAddress}async PAUSER_ROLE(){return this.state.pauserRole}async minCommissionIncreaseInterval(){return this.state.minCommissionIncreaseInterval}async maxCommissionIncrease(){return this.state.maxCommissionIncrease}async activeStake(){return H((e,t)=>e+t,0n,Me(this.state.delegations,([,e])=>B(e,([,t])=>t)))}async commissionTracking(e){return this.state.commissionTracking.get(e)??[0,0n]}async lightClient(){return"0xLIGHT_CLIENT_ADDRESS"}async token(){return this.espToken.address}async validator(e){const t=this.state.validators.get(e)??[0n,0];return Re.fromRaw(t)}async blsKey(){throw new Error("Method not implemented.")}async validatorExit(e){return this.state.validatorExits.get(e)??0n}async delegation(e,t){return this.state.delegations.get(e)?.get(t)??0n}async undelegation(e,t){const n=this.state.undelegations.get(e)?.get(t)??[0n,0n];return Ve.fromRaw(n)}async exitEscrowPeriod(){return this.state.exitEscrowPeriod}async getVersion(){return[2,0,0]}async updateConsensusKeysV2(){throw new Error("Method not implemented.")}async deregisterValidator(){if(!this.accountAddress)throw new Error("No account address available for deregistering validator.");const e=await this.validator(this.accountAddress);if(e.status===C.exited)throw new Error("Validator has already exited");if(e.status!==C.active)throw new Error("Validator is not active");const t=new ee(this.address,this.accountAddress,BigInt(Date.now())+this.state.exitEscrowPeriod);return _(this.l1Methods,t),t.hash()}async delegate(e,t){if(t<=0n)throw new Error("Amount must be greater than zero");if(!this.accountAddress)throw new Error("No account address available for delegation.");if((await this.validator(e)).status!==C.active)throw new Error("Validator is not active");if(await this.espToken.balanceOf(this.accountAddress)<t)throw new Error("Insufficient balance");await this.espToken.transferFrom(this.accountAddress,this.address,t);const a=new J(this.address,e,this.accountAddress,t);return _(this.l1Methods,a),a.hash()}async undelegate(e,t){if(!this.accountAddress)throw new Error("No account address available for undelegation.");if(t<=0n)throw new Error("Amount must be greater than zero");if(await this.delegation(e,this.accountAddress)<t)throw new Error("Insufficient delegated amount");const a=this.state;if(a.validatorExits.has(e))throw new Error("Validator is exiting, cannot undelegate");if(a.undelegations.get(e)?.has(this.accountAddress))throw new Error("Existing undelegation in progress");const r=new X(this.address,e,this.accountAddress,t,this.state.exitEscrowPeriod);return _(this.l1Methods,r),r.hash()}async claimWithdrawal(e){const t=BigInt(Date.now());if(!this.accountAddress)throw new Error("No account address available for claim withdrawal.");const n=await this.undelegation(e,this.accountAddress);if(!n.amount)throw new Error("No undelegation found for this delegator and validator.");if(t<n.timestamp)throw new Error("Undelegation period has not yet elapsed.");await this.espToken.transfer(this.accountAddress,n.amount);const a=new Q(this.address,e,this.accountAddress,n.amount);return _(this.l1Methods,a),a.hash()}async claimValidatorExit(e){const t=BigInt(Date.now());if(!this.accountAddress)throw new Error("No account address available for claim validator exit.");const n=await this.validatorExit(e)??null;if(n===null)throw new Error("Validator is not exiting.");const a=await this.delegation(e,this.accountAddress);if(a<=0n)throw new Error("No stake found for this delegator and validator.");if(t<n)throw new Error("Validator exit period has not yet elapsed.");await this.espToken.transfer(this.accountAddress,a);const r=new Y(this.address,e,this.accountAddress,a);return _(this.l1Methods,r),r.hash()}}function $e(s,e){const t="0x0000000000000000000000000000000000000002";S(s instanceof g,"expected espTokenContract to be an instance of MockESPTokenContractImpl");const[n]=i.useState(new y(e?.contractAddress??t,e?.validators??new Map,e?.blsKeys??new Set,e?.validatorExits??new Map,e?.delegations??new Map,e?.undelegations??new Map,e?.exitEscrowPeriod??60000n,e?.pauserRole??"0xPAUSER_ROLE",e?.minCommissionIncreaseInterval??60000n,e?.maxCommissionIncrease??1,e?.commissionTracking??new Map,e?.schnorrKeys??new Set,new Date));return n}const te=({children:s})=>{const e=i.useContext(R),t=i.useContext(G),n=i.useContext(ne);m(e),m(n),S(e instanceof T),S(n instanceof g);const a=new Map(Ce(B(Se(k,k.length-2),d=>{const p=u.encode(d.address);return[p,new Map([[p,d.stake]])]}),B(se(k,k.length-2),d=>{const p=u.encode(d.address);return[p,new Map([[p,d.stake*9n/10n],[I,d.stake*1n/10n]])]}))),r=$e(n,{validators:new Map(B(a,([d,p])=>[d,[H((M,E)=>M+E,0n,(a.get(d)??new Map).values()),p.size>1?C.exited:C.active]])),delegations:a,validatorExits:new Map(B(se(k,k.length-2),d=>[u.encode(d.address),0n]))}),[c]=i.useState(new P(e,n,r,t));i.useEffect(()=>(c.setAccountAddress(t),()=>{}),[c,t]);const l=new Ze;return o.jsx(K.Provider,{value:c,children:o.jsx(de.Provider,{value:c,children:o.jsx(O.Provider,{value:l,children:o.jsx(le.Provider,{value:l,children:s})})})})};try{y.displayName="StakeTableState",y.__docgenInfo={description:`StakeTableState defines the structure of the mock
StakeTableV2Contract state.`,displayName:"StakeTableState",props:{}}}catch{}try{b.displayName="StakeTableStateActions",b.__docgenInfo={description:`StakeTableStateActions is an abstract base class
representing an action that modifies the state of the
MockStakeTableV2Contract.`,displayName:"StakeTableStateActions",props:{}}}catch{}try{J.displayName="Delegate",J.__docgenInfo={description:`Delegate represents a delegation action in the StakeTableState.
It records the validator, delegator, and amount delegated.`,displayName:"Delegate",props:{}}}catch{}try{X.displayName="Undelegate",X.__docgenInfo={description:`Undelegate represents an undelegation action in the StakeTableState.
It records the validator, delegator, and amount undelegated.`,displayName:"Undelegate",props:{}}}catch{}try{Q.displayName="ClaimWithdrawal",Q.__docgenInfo={description:`ClaimWithdrawal represents a claim withdrawal action
within the StakeTableState.`,displayName:"ClaimWithdrawal",props:{}}}catch{}try{Y.displayName="ClaimValidatorExit",Y.__docgenInfo={description:`ClaimWithdrawal represents a claim withdrawal action
within the StakeTableState.`,displayName:"ClaimValidatorExit",props:{}}}catch{}try{ee.displayName="ValidatorExit",ee.__docgenInfo={description:`ValidatorExit represents a validator exit action
within the MockStakeTableV2Contract.`,displayName:"ValidatorExit",props:{}}}catch{}try{P.displayName="MockStakeTableV2ContractImpl",P.__docgenInfo={description:`MockStakeTableV2ContractImpl is a mock implementation of the
StakeTableV2Contract interface for testing and development purposes.`,displayName:"MockStakeTableV2ContractImpl",props:{}}}catch{}try{te.displayName="MockStakeTableV2Contract",te.__docgenInfo={description:`MockStakeTableV2Contract is a React component that provides
a mock StakeTableV2Contract implementation via context for
testing and development purposes.

It will overwrite the StakeTableV2ContractContext with a mock
implementation that simulates the behavior of an actual
StakeTableV2Contract.

It **MUST** be given a valid ESPTokenContract via the
\`ESPTokenContractContext\` context.

It pre-populates the delegations mapping with initial stakes
derived from the \`nodeList\` fake data.`,displayName:"MockStakeTableV2Contract",props:{}}}catch{}const ie=({children:s})=>{const e=i.useContext(ge),t=i.useContext(ce);return e!==fe.fakeData||t?.espTokenContractAddress||t?.stakeTableContractAddress?o.jsx(o.Fragment,{children:s}):o.jsx(z,{children:o.jsx(Je,{children:s})})},Je=({children:s})=>o.jsx(W,{children:o.jsx(L,{children:o.jsx(Z,{children:o.jsx(te,{children:o.jsx($,{children:s})})})})});try{ie.displayName="FakeDataMockOverrides",ie.__docgenInfo={description:`FakeDataMockOverrides is a React component that provides
mock overrides for various contexts when the environment
is set to FakeData and the relevant contracts are not
already provided in the Espresso configuration.`,displayName:"FakeDataMockOverrides",props:{}}}catch{}export{Q as C,J as D,ie as F,T as M,re as P,ue as R,b as S,X as U,ee as V,I as a,Y as b,ze as c};
