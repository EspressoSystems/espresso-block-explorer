var x=Object.defineProperty;var $=(r,e,o)=>e in r?x(r,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):r[e]=o;var n=(r,e,o)=>$(r,typeof e!="symbol"?e+"":e,o);class i extends Error{constructor(o,t,a=`expected object with key: "${t}", instead found ${o}`){super(a);n(this,"key");n(this,"haveType");this.haveType=o,this.key=t,Object.freeze(this)}toJSON(){return{code:i.name,message:this.message,have:this.haveType,key:this.key}}}class l{encode(e){return this.encoder.convert(e)}decode(e){return this.decoder.convert(e)}}class c extends l{}function oe(r){return typeof r=="boolean"}function ne(r){return typeof r=="number"}function u(r){return typeof r=="string"}function v(r){return typeof r=="object"&&r!==null}function k(r){return r!==void 0}function N(r,e){return Array.isArray(r)&&r.every(e)}function j(r){return e=>N(e,r)}function te(r,e,o){return v(r)&&e in r&&o(r[e])}function se(r,...e){return v(r)&&e.every(o=>o in r)}function C(r,...e){if(typeof r!="object")throw new Error("expected object");if(r===null)throw new Error("received null");for(const o of e)if(!(o in r))throw new i("object",o)}function A(r,e){if(!u(r.code))throw new Error("code must be a string");if(r.code!==e)throw new Error(`expected code to be ${e}, got ${r.code}`)}function ce(r,e){if(!u(r.type))throw new Error("type must be a string");if(r.type!==e)throw new Error(`expected type to be ${e}, got ${r.type}`)}class T{assert(){}}function O(){return new T}const S=O();function f(r,e){S.assert(r,e)}function I(r,e){f(typeof r===e,`type assertion failed: expected "${e}", received "${typeof r}"`)}function D(r){f(r!==null,"expected a non-null value, received null")}function w(r,e){f(r instanceof e,`given value is not an instance of "${e.name}", specific type is "${typeof r=="object"&&r!==null?r.constructor.name:typeof r}"`)}class g extends Error{constructor(e){super(e)}get code(){return this.constructor.name}toJSON(){return p.convert(this)}}class R{convert(e){return w(e,g),{code:e.code,message:e.message}}}const p=new R,z="NoCodecFoundError";class d extends Error{constructor(o,t=`no codec found for: "${o}"`){super(t);n(this,"codec");this.codec=o,Object.freeze(this);debugger}toJSON(){return{code:s.encode(d.name),message:s.encode(this.message),codec:s.encode(this.codec)}}get code(){return z}}const h=new Map;class B{convert(e){C(e,"code");const o=s.decode(e.code),t=h.get(o);if(!t)throw new d(o);return t.decode(e)}}class J{convert(e){const o=h.get(e.code);if(!o)throw new d(e.code);return o.encode(e)}}class U extends l{constructor(){super(...arguments);n(this,"encoder",new J);n(this,"decoder",new B)}}const de=new U;function F(r,e){h.set(r,e)}const y="InvalidTypeError";class E extends g{constructor(o,t,a=`invalid type: have "${o}", want "${t}"`){super(a);n(this,"have");n(this,"want");this.have=o,this.want=t,Object.freeze(this)}toJSON(){return b.encode(this)}get code(){return y}}class K{convert(e){return C(e,"code","have","want","message"),A(e,y),new E(s.decode(e.have),s.decode(e.want),s.decode(e.message))}}class M{convert(e){return w(e,E),{...p.convert(e),have:s.encode(e.have),want:s.encode(e.want)}}}class W extends c{constructor(){super(...arguments);n(this,"encoder",new M);n(this,"decoder",new K)}}const b=new W;F(y,b);const q=j(k);class G{convert(e){return e}}const m=new G;class H extends l{constructor(){super(...arguments);n(this,"encoder",m);n(this,"decoder",m)}}const ae=new H;class L{constructor(e){n(this,"itemCodec");this.itemCodec=e}convert(e){if(!q(e)){const o=typeof e=="object"&&e!==null?e.constructor.name:typeof e,t="array";throw new Error(`invalid array value: have "${o}", want "${t}"`)}return e.map(o=>this.itemCodec.decode(o))}}class P{constructor(e){n(this,"itemCodec");this.itemCodec=e}convert(e){return w(e,Array),e.map(o=>this.itemCodec.encode(o))}}class Q extends c{constructor(o,t){super();n(this,"encoder");n(this,"decoder");this.encoder=t,this.decoder=o}}class V{constructor(e){n(this,"itemCodec");this.itemCodec=e}convert(e){return e===null?null:this.itemCodec.decode(e)}}class X{constructor(e){n(this,"itemCodec");this.itemCodec=e}convert(e){return e===null?null:(D(e),this.itemCodec.encode(e))}}class Y extends c{constructor(o,t){super();n(this,"encoder");n(this,"decoder");this.encoder=t,this.decoder=o}}class Z{convert(e){if(!u(e))throw new E(typeof e,"string");return e}}class _{convert(e){return I(e,"string"),e}}class ee extends c{constructor(){super(...arguments);n(this,"encoder",new _);n(this,"decoder",new Z)}}const s=new ee;new Q(new L(s),new P(s));const ie=new Y(new V(s),new X(s));function le(r){return!r||!r.trim()?null:r}export{Q as A,g as B,l as C,E as I,Y as N,c as T,C as a,A as b,p as c,R as d,I as e,V as f,X as g,u as h,oe as i,w as j,L as k,P as l,ce as m,ne as n,d as o,le as p,se as q,F as r,s,de as t,ae as u,ie as v,f as w,q as x,te as y,k as z};
