var x=Object.defineProperty;var $=(r,e,o)=>e in r?x(r,e,{enumerable:!0,configurable:!0,writable:!0,value:o}):r[e]=o;var n=(r,e,o)=>$(r,typeof e!="symbol"?e+"":e,o);class i extends Error{constructor(o,s,a=`expected object with key: "${s}", instead found ${o}`){super(a);n(this,"key");n(this,"haveType");this.haveType=o,this.key=s,Object.freeze(this)}toJSON(){return{code:i.name,message:this.message,have:this.haveType,key:this.key}}}class u{encode(e){return this.encoder.convert(e)}decode(e){return this.decoder.convert(e)}}class c extends u{}function oe(r){return typeof r=="boolean"}function ne(r){return typeof r=="number"}function l(r){return typeof r=="string"}function v(r){return typeof r=="object"&&r!==null}function k(r){return r!==void 0}function N(r,e){return Array.isArray(r)&&r.every(e)}function j(r){return e=>N(e,r)}function se(r,e,o){return v(r)&&e in r&&o(r[e])}function te(r,...e){return v(r)&&e.every(o=>o in r)}function m(r,...e){if(typeof r!="object")throw new Error("expected object");if(r===null)throw new Error("received null");for(const o of e)if(!(o in r))throw new i("object",o)}function A(r,e){if(!l(r.code))throw new Error("code must be a string");if(r.code!==e)throw new Error(`expected code to be ${e}, got ${r.code}`)}function ce(r,e){if(!l(r.type))throw new Error("type must be a string");if(r.type!==e)throw new Error(`expected type to be ${e}, got ${r.type}`)}class T{assert(){}}function O(){return new T}const S=O();function w(r,e){S.assert(r,e)}function I(r,e){w(typeof r===e,`type assertion failed: expected "${e}", received "${typeof r}"`)}function D(r){w(r!==null,"expected a non-null value, received null")}function f(r,e){w(r instanceof e,`given value is not an instance of "${e.name}", specific type is "${typeof r=="object"&&r!==null?r.constructor.name:typeof r}"`)}class g extends Error{constructor(e){super(e)}get code(){return this.constructor.name}toJSON(){return p.convert(this)}}class R{convert(e){return f(e,g),{code:e.code,message:e.message}}}const p=new R,B="NoCodecFoundError";class d extends Error{constructor(o,s=`no codec found for: "${o}"`){super(s);n(this,"codec");this.codec=o,Object.freeze(this);debugger}toJSON(){return{code:t.encode(d.name),message:t.encode(this.message),codec:t.encode(this.codec)}}get code(){return B}}const h=new Map;class J{convert(e){m(e,"code");const o=t.decode(e.code),s=h.get(o);if(!s)throw new d(o);return s.decode(e)}}class U{convert(e){const o=h.get(e.code);if(!o)throw new d(e.code);return o.encode(e)}}class z extends u{constructor(){super(...arguments);n(this,"encoder",new U);n(this,"decoder",new J)}}const de=new z;function F(r,e){h.set(r,e)}const y="InvalidTypeError";class E extends g{constructor(o,s,a=`invalid type: have "${o}", want "${s}"`){super(a);n(this,"have");n(this,"want");this.have=o,this.want=s,Object.freeze(this)}toJSON(){return b.encode(this)}get code(){return y}}class K{convert(e){return m(e,"code","have","want","message"),A(e,y),new E(t.decode(e.have),t.decode(e.want),t.decode(e.message))}}class M{convert(e){return f(e,E),{...p.convert(e),have:t.encode(e.have),want:t.encode(e.want)}}}class W extends c{constructor(){super(...arguments);n(this,"encoder",new M);n(this,"decoder",new K)}}const b=new W;F(y,b);const q=j(k);class G{convert(e){return e}}const C=new G;class H extends u{constructor(){super(...arguments);n(this,"encoder",C);n(this,"decoder",C)}}const ae=new H;class L{constructor(e){n(this,"itemCodec");this.itemCodec=e}convert(e){if(!q(e)){const o=typeof e=="object"&&e!==null?e.constructor.name:typeof e,s="array";throw new Error(`invalid array value: have "${o}", want "${s}"`)}return e.map(o=>this.itemCodec.decode(o))}}class P{constructor(e){n(this,"itemCodec");this.itemCodec=e}convert(e){return f(e,Array),e.map(o=>this.itemCodec.encode(o))}}class Q extends c{constructor(o,s){super();n(this,"encoder");n(this,"decoder");this.encoder=s,this.decoder=o}}class V{constructor(e){n(this,"itemCodec");this.itemCodec=e}convert(e){return e===null?null:this.itemCodec.decode(e)}}class X{constructor(e){n(this,"itemCodec");this.itemCodec=e}convert(e){return e===null?null:(D(e),this.itemCodec.encode(e))}}class Y extends c{constructor(o,s){super();n(this,"encoder");n(this,"decoder");this.encoder=s,this.decoder=o}}class Z{convert(e){if(!l(e))throw new E(typeof e,"string");return e}}class _{convert(e){return I(e,"string"),e}}class ee extends c{constructor(){super(...arguments);n(this,"encoder",new _);n(this,"decoder",new Z)}}const t=new ee;new Q(new L(t),new P(t));const ie=new Y(new V(t),new X(t));export{Q as A,g as B,u as C,E as I,Y as N,c as T,m as a,A as b,p as c,R as d,V as e,X as f,f as g,L as h,l as i,P as j,ce as k,ne as l,I as m,d as n,w as o,de as p,q,F as r,t as s,se as t,ae as u,k as v,oe as w,ie as x,te as y};
