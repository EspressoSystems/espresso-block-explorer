import{b as d,d as g,c as b}from"./assert-BI051aL8.js";class a extends Error{key;haveType;constructor(e,o,s=`expected object with key: "${o}", instead found ${e}`){super(s),this.haveType=e,this.key=o,Object.freeze(this)}toJSON(){return{code:a.name,message:this.message,have:this.haveType,key:this.key}}}class i{encode(e){return this.encoder.convert(e)}decode(e){return this.decoder.convert(e)}}class t extends i{}function Q(r){return typeof r=="boolean"}function V(r){return typeof r=="number"}function l(r){return typeof r=="string"}function X(r){return typeof r=="bigint"}function y(r){return typeof r=="object"&&r!==null}function p(r){return r!==void 0}function x(r,e){return Array.isArray(r)&&r.every(e)}function k(r){return e=>x(e,r)}function Y(r,e,o){return y(r)&&e in r&&o(r[e])}function Z(r,...e){return y(r)&&e.every(o=>o in r)}function E(r,...e){if(typeof r!="object")throw new Error("expected object");if(r===null)throw new Error("received null");for(const o of e)if(!(o in r))throw new a("object",o)}function N(r,e){if(!l(r.code))throw new Error("code must be a string");if(r.code!==e)throw new Error(`expected code to be ${e}, got ${r.code}`)}function _(r,e){if(!l(r.type))throw new Error("type must be a string");if(r.type!==e)throw new Error(`expected type to be ${e}, got ${r.type}`)}class m extends Error{constructor(e){super(e)}get code(){return this.constructor.name}toJSON(){return v.convert(this)}}class j{convert(e){return d(e,m),{code:e.code,message:e.message}}}const v=new j,T="NoCodecFoundError";class c extends Error{codec;constructor(e,o=`no codec found for: "${e}"`){super(o),this.codec=e,Object.freeze(this);debugger}toJSON(){return{code:n.encode(c.name),message:n.encode(this.message),codec:n.encode(this.codec)}}get code(){return T}}const u=new Map;class ${convert(e){E(e,"code");const o=n.decode(e.code),s=u.get(o);if(!s)throw new c(o);return s.decode(e)}}class A{convert(e){const o=u.get(e.code);if(!o)throw new c(e.code);return o.encode(e)}}class O extends i{encoder=new A;decoder=new $}const ee=new O;function S(r,e){u.set(r,e)}const w="InvalidTypeError";class h extends m{have;want;constructor(e,o,s=`invalid type: have "${e}", want "${o}"`){super(s),this.have=e,this.want=o,Object.freeze(this)}toJSON(){return C.encode(this)}get code(){return w}}class I{convert(e){return E(e,"code","have","want","message"),N(e,w),new h(n.decode(e.have),n.decode(e.want),n.decode(e.message))}}class B{convert(e){return d(e,h),{...v.convert(e),have:n.encode(e.have),want:n.encode(e.want)}}}class D extends t{encoder=new B;decoder=new I}const C=new D;S(w,C);const J=k(p);class R{convert(e){return e}}const f=new R;class U extends i{encoder=f;decoder=f}const re=new U;class z{itemCodec;constructor(e){this.itemCodec=e}convert(e){if(!J(e)){const o=typeof e=="object"&&e!==null?e.constructor.name:typeof e,s="array";throw new Error(`invalid array value: have "${o}", want "${s}"`)}return e.map(o=>this.itemCodec.decode(o))}}class F{itemCodec;constructor(e){this.itemCodec=e}convert(e){return d(e,Array),e.map(o=>this.itemCodec.encode(o))}}class K extends t{encoder;decoder;constructor(e,o){super(),this.encoder=o,this.decoder=e}}class M{itemCodec;constructor(e){this.itemCodec=e}convert(e){return e===null?null:this.itemCodec.decode(e)}}class W{itemCodec;constructor(e){this.itemCodec=e}convert(e){return e===null?null:(g(e),this.itemCodec.encode(e))}}class q extends t{encoder;decoder;constructor(e,o){super(),this.encoder=o,this.decoder=e}}class G{convert(e){if(!l(e))throw new h(typeof e,"string");return e}}class H{convert(e){return b(e,"string"),e}}class L extends t{encoder=new H;decoder=new G}const n=new L;new K(new z(n),new F(n));const oe=new q(new M(n),new W(n));function ne(r){return!r||!r.trim()?null:r}export{K as A,m as B,i as C,h as I,q as N,t as T,j as a,E as b,N as c,v as d,M as e,W as f,V as g,l as h,X as i,z as j,F as k,_ as l,c as m,ee as n,oe as o,ne as p,Z as q,S as r,n as s,Q as t,re as u,J as v,Y as w,p as x};
